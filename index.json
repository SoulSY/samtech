[{"content":"Overview The Prototype pattern is a design pattern that allows the creation of objects by cloning existing objects, reducing the cost of object creation. The Prototype pattern consists of the following elements:\nPrototype Interface or Abstract Class: Defines the cloning method that declares the ability to clone an object. ConcretePrototype Class: Implements the Prototype interface concretely and provides the cloning method to perform object cloning. Client: Requests the cloning operation and creates new objects. // Prototype Interface public interface Prototype { Prototype clone(); } // ConcretePrototype Class public class ConcretePrototype implements Prototype { private String property; public ConcretePrototype(String property) { this.property = property; } public Prototype clone() { return new ConcretePrototype(this.property); } public void setProperty(String property) { this.property = property; } public String getProperty() { return property; } } // Client Class public class Client { public static void main(String[] args) { // Create an original object ConcretePrototype prototype = new ConcretePrototype(\u0026quot;Original\u0026quot;); // Clone the object ConcretePrototype clonedObject = (ConcretePrototype) prototype.clone(); // Change the property of the cloned object clonedObject.setProperty(\u0026quot;Cloned\u0026quot;); System.out.println(\u0026quot;Original Object: \u0026quot; + prototype.getProperty()); System.out.println(\u0026quot;Cloned Object: \u0026quot; + clonedObject.getProperty()); } } In the above example code, we define the Prototype interface and have the ConcretePrototype class implementing it. The ConcretePrototype class provides the clone() method to clone itself. In the Client class, we create an original object and then clone it to create a new object. We modify the property of the cloned object and print the results.\nAdvantages Reduces the cost of object creation by cloning existing objects. It avoids expensive initialization operations. Simplifies the object creation process. Instead of complex initialization, it clones the existing object and makes necessary modifications. Considerations Be careful about shallow copy and deep copy during the cloning process. Shallow copy only copies the references of the referred objects, so the original and cloned objects may still refer to the same objects. Deep copy creates new instances of the referred objects, ensuring that the original and cloned objects refer to independent objects. When an object has complex state, ensure that all state is accurately cloned. Take care while implementing the cloning method. The Prototype pattern may become challenging to handle structural changes in objects dynamically. If the object\u0026rsquo;s structure changes, you may need to modify all the cloning-related code. Here\u0026rsquo;s an example of incorrectly implementing object cloning and not using the Prototype pattern correctly:\n// Prototype Interface public interface Prototype { Prototype clone(); } // ConcretePrototype Class public class ConcretePrototype implements Prototype { private int[] array; public ConcretePrototype(int[] array) { this.array = array; } public Prototype clone() { return new ConcretePrototype(this.array); // Incorrect cloning approach } public void setArrayValue(int index, int value) { array[index] = value; } public int[] getArray() { return array; } } // Client Class public class Client { public static void main(String[] args) { // Create the original object int[] originalArray = {1, 2, 3}; ConcretePrototype prototype = new ConcretePrototype(originalArray); // Clone the object ConcretePrototype clonedObject = (ConcretePrototype) prototype.clone(); // Modify the array value of the cloned object clonedObject.setArrayValue(0 , 99); System.out.println(\u0026quot;Original Array: \u0026quot; + Arrays.toString(prototype.getArray())); System.out.println(\u0026quot;Cloned Array: \u0026quot; + Arrays.toString(clonedObject.getArray())); } } In the above example code, the clone() method in the ConcretePrototype class performs shallow copying of the array. As a result, the original and cloned objects end up referencing the same array object. Therefore, when modifying the array value of the cloned object, the array value of the original object also changes.\nIn such cases, the correct approach is to perform deep copying to ensure that the cloned object and the original object refer to independent array objects. For example, you can create a new array instance and copy the array elements to perform cloning correctly.\nPatterns Used with the Prototype Pattern Abstract Factory Pattern: The Abstract Factory pattern can be used to manage Prototype instances and create new objects based on them. Builder Pattern: The Builder pattern can be used to clone Prototype objects and perform additional configuration operations. Singleton Pattern: The Singleton pattern can be used to share Prototype instances and create new objects by cloning them when needed. ","permalink":"https://soulsy.github.io/samtech/dev/design_pattern/prototype_pattern/","title":"Design Pattern 05. Prototype Pattern"},{"content":"Overview The Builder pattern is a design pattern that provides a flexible and intuitive way to create objects. It abstracts the complex object creation process and allows users to construct objects step by step.\nThe Builder pattern consists of the following elements:\nDirector: Responsible for object creation and uses the Builder interface to construct the object. Builder: Defines the interface for object creation and provides methods to build each part of the object. ConcreteBuilder: Implements the Builder interface to construct and configure the actual object. Product: Represents the final object being created. // Product class public class Product { private String partA; private String partB; private String partC; public void setPartA(String partA) { this.partA = partA; } public void setPartB(String partB) { this.partB = partB; } public void setPartC(String partC) { this.partC = partC; } public String getResult() { return \u0026quot;Part A: \u0026quot; + partA + \u0026quot;, Part B: \u0026quot; + partB + \u0026quot;, Part C: \u0026quot; + partC; } } // Builder interface public interface Builder { void buildPartA(); void buildPartB(); void buildPartC(); Product getResult(); } // ConcreteBuilder class public class ConcreteBuilder implements Builder { private Product product; public ConcreteBuilder() { this.product = new Product(); } public void buildPartA() { product.setPartA(\u0026quot;A\u0026quot;); } public void buildPartB() { product.setPartB(\u0026quot;B\u0026quot;); } public void buildPartC() { product.setPartC(\u0026quot;C\u0026quot;); } public Product getResult() { return product; } } // Director class public class Director { private Builder builder; public void setBuilder(Builder builder) { this.builder = builder; } public Product construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); return builder.getResult(); } } // Example usage public class Main { public static void main(String[] args) { Director director = new Director(); Builder builder = new ConcreteBuilder(); director.setBuilder(builder); Product product = director.construct(); System.out.println(product.getResult()); } } In the above example code, the Builder pattern is used to create and construct a Product object. The Builder interface defines the methods for object creation, and the ConcreteBuilder class implements the interface to construct and configure the actual object. The Director class uses the Builder interface to orchestrate the object creation process and returns the final Product object.\nThis example code demonstrates the basic implementation of the Builder pattern. It can be extended and enhanced as per requirements, such as adding validation for object properties, to create a complete and robust implementation of the Builder pattern in a production environment.\nAdvantages The Builder pattern has the following advantages:\nIt allows the construction of objects in a step-by-step manner, making the object\u0026rsquo;s construction process clear and flexible. It enables the creation of readable code when constructing complex objects. It ensures the consistency and stability of objects by not exposing the object\u0026rsquo;s construction process to the client. Considerations Here are some considerations when using the Builder pattern:\nSince the object construction process is performed step-by-step, some parts of the object may be in an invalid state if not properly handled. To prevent this, validation for object properties should be performed. The Builder pattern is typically used for creating complex objects, and it may not be efficient for simple objects. If the object has few or simple construction steps, considering other creational patterns may be more appropriate.\nHere is an example code that demonstrates the inefficient use of the Builder pattern for creating a simple object:\npublic class SimpleObject { private String propertyA; private String propertyB; private String propertyC; public SimpleObject(String propertyA, String propertyB, String propertyC) { this.propertyA = propertyA; this.propertyB = propertyB; this.propertyC = propertyC; } // Getters and setters } public class SimpleObjectBuilder { private String propertyA; private String propertyB; private String propertyC; public SimpleObjectBuilder() { } public SimpleObjectBuilder setPropertyA(String propertyA) { this.propertyA = propertyA; return this; } public SimpleObjectBuilder setPropertyB(String propertyB) { this.propertyB = propertyB; return this; } public SimpleObjectBuilder setPropertyC(String propertyC) { this.propertyC = propertyC; return this; } public SimpleObject build() { return new SimpleObject(propertyA, propertyB, propertyC); } } public class Main { public static void main(String[] args) { SimpleObjectBuilder builder = new SimpleObjectBuilder(); SimpleObject simpleObject = builder.setPropertyA(\u0026quot;A\u0026quot;) .setPropertyB(\u0026quot;B\u0026quot;) .setPropertyC(\u0026quot;C\u0026quot;) .build(); } } In the above example code, the Builder pattern is used to create a simple object SimpleObject. However, since the SimpleObject class already provides a constructor that can directly initialize the required properties, using the Builder pattern in this case is inefficient. It adds an unnecessary intermediate step of SimpleObjectBuilder, making the code more complex and less readable.\nA more efficient approach is to directly create the SimpleObject object as follows:\npublic class Main { public static void main(String[] args) { SimpleObject simpleObject = new SimpleObject(\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;); } } By doing so, you can create a simple object without the need for an unnecessary Builder class, resulting in more concise and readable code.\nOther Patterns Used with the Builder Pattern The Builder pattern can be used in conjunction with other design patterns. Some commonly used patterns with the Builder pattern include:\nAbstract Factory Pattern: The Abstract Factory pattern can be used to create multiple Builder interfaces and corresponding ConcreteBuilders, allowing the creation of different types of objects. Prototype Pattern: The Prototype pattern can be used to clone existing objects and then modify or add configurations using the Builder pattern. Uniform Interface Pattern: The Builder pattern can be used to create and configure multiple objects using a uniform interface for object creation and configuration. ","permalink":"https://soulsy.github.io/samtech/dev/design_pattern/builder_pattern/","title":"Design Pattern 04. Builder Pattern"},{"content":"The Singleton pattern ensures that a class has only one instance of its object and provides a global access point to it.\nOverview The Singleton pattern has the following characteristics:\nThere is only one instance of the class. It provides a global access point, allowing access to the same instance from anywhere. The Singleton pattern can be useful in various situations and is a commonly used pattern.\nAdvantages The Singleton pattern offers the following advantages:\nIt minimizes resource usage by ensuring that only one instance exists. It provides easy access to the instance through a global access point. Common Mistakes Mistakes in using the Singleton pattern can lead to the following problems:\nIn a multi-threaded environment, synchronization issues can arise. If multiple threads request instance creation simultaneously, multiple instances may be created. It can negatively impact testability. Since the Singleton instance is accessed globally and not injected as a dependency, it can be challenging to test. It can violate the Single Responsibility Principle. If the Singleton class includes additional functionality to maintain instance uniqueness, it may take on too many responsibilities. An example of a wrongly implemented Singleton pattern is when multiple threads can create instances concurrently, resulting in multiple instances or inconsistent instance state. Here is an example code demonstrating such an issue:\npublic class BadSingleton { private static BadSingleton instance; private BadSingleton() { // Instance creation logic } public static BadSingleton getInstance() { if (instance == null) { // Multiple threads can simultaneously enter this section instance = new BadSingleton(); } return instance; } // Other methods and data members } In the above code, the getInstance() method can suffer from a race condition where multiple threads enter the section that checks for instance being null simultaneously. This can result in different instances being created.\nTo address this issue, synchronization needs to be implemented. Here is an example of a properly synchronized Singleton pattern code:\npublic class GoodSingleton { private static GoodSingleton instance; private GoodSingleton() { // Instance creation logic } public static synchronized GoodSingleton getInstance() { if (instance == null) { instance = new GoodSingleton(); } return instance; } // Other methods and data members } In the above code, the getInstance() method is synchronized using the synchronized keyword. This prevents multiple threads from simultaneously accessing the method, ensuring that only one thread creates the instance.\nWhen used correctly, the Singleton pattern ensures safe usage in a multi-threaded environment. However, it is important to exercise caution and use the pattern only when necessary.\nPatterns That Work Well with the Singleton Pattern A pattern that works well with the Singleton pattern is the Abstract Factory pattern. By applying the Singleton pattern to the factory class, you can ensure consistent object creation.\nHere is an example code demonstrating the combination of the Singleton pattern and the Abstract Factory pattern:\n// SingletonFactory with Singleton pattern for Abstract Factory public class SingletonFactory implements AbstractFactory { private static SingletonFactory instance; private SingletonFactory() { // Instance creation logic } public static synchronized SingletonFactory getInstance() { if (instance == null) { instance = new SingletonFactory(); } return instance; } public AbstractProductA createProductA() { return new ConcreteProductA(); } public AbstractProductB createProductB() { return new ConcreteProductB(); } } // Abstract Factory interface public interface AbstractFactory { AbstractProductA createProductA(); AbstractProductB createProductB(); } // Concrete product classes public class ConcreteProductA implements AbstractProductA { // Implementation of Product A } public class ConcreteProductB implements AbstractProductB { // Implementation of Product B } In the above example, the SingletonFactory class implements the AbstractFactory interface using the Singleton pattern. The SingletonFactory instance is maintained as a single instance according to the Singleton pattern, and the createProductA and createProductB methods create objects.\nBy combining the Singleton pattern with the Abstract Factory pattern in this way, the Singleton pattern ensures that the concrete factory class\u0026rsquo;s instance remains unique, allowing consistent object creation.\nI hope this provides a better understanding of the Singleton pattern and its correct usage. Let me know if you have any further questions!\n","permalink":"https://soulsy.github.io/samtech/dev/design_pattern/singleton_pattern/","title":"Design Pattern 03. Singleton Pattern"},{"content":"The Abstract Factory pattern is a design pattern that provides an interface for creating related objects, separating the responsibility of object creation. This pattern is useful when multiple objects that are related to each other need to be created, and it allows creating objects without depending on specific classes.\nOverview The Abstract Factory pattern allows clients to create objects through an abstract factory interface instead of directly creating them. The abstract factory provides an interface for a set of related objects, and concrete factory classes implement this interface to create actual objects. This allows clients to create objects without directly depending on concrete classes.\nExample Code // Abstract Product A public interface AbstractProductA { void performAction(); } // Abstract Product B public interface AbstractProductB { void performAction(); } // Concrete Product A1 public class ConcreteProductA1 implements AbstractProductA { @Override public void performAction() { System.out.println(\u0026quot;Performing action in ConcreteProductA1\u0026quot;); } } // Concrete Product A2 public class ConcreteProductA2 implements AbstractProductA { @Override public void performAction() { System.out.println(\u0026quot;Performing action in ConcreteProductA2\u0026quot;); } } // Concrete Product B1 public class ConcreteProductB1 implements AbstractProductB { @Override public void performAction() { System.out.println(\u0026quot;Performing action in ConcreteProductB1\u0026quot;); } } // Concrete Product B2 public class ConcreteProductB2 implements AbstractProductB { @Override public void performAction() { System.out.println(\u0026quot;Performing action in ConcreteProductB2\u0026quot;); } } // Abstract Factory interface public interface AbstractFactory { AbstractProductA createProductA(); AbstractProductB createProductB(); } // Concrete Factory A public class ConcreteFactoryA implements AbstractFactory { @Override public AbstractProductA createProductA() { return new ConcreteProductA1(); } @Override public AbstractProductB createProductB() { return new ConcreteProductB1(); } } // Concrete Factory B public class ConcreteFactoryB implements AbstractFactory { @Override public AbstractProductA createProductA() { return new ConcreteProductA2(); } @Override public AbstractProductB createProductB() { return new ConcreteProductB2(); } } // Client code public class Client { private AbstractProductA productA; private AbstractProductB productB; public Client(AbstractFactory factory) { productA = factory.createProductA(); productB = factory.createProductB(); } public void performActions() { productA.performAction(); productB.performAction(); } public static void main(String[] args) { AbstractFactory factoryA = new ConcreteFactoryA(); Client clientA = new Client(factoryA); clientA.performActions(); // Output: // Performing action in ConcreteProductA1 // Performing action in ConcreteProductB1 AbstractFactory factoryB = new ConcreteFactoryB(); Client clientB = new Client(factoryB); clientB.performActions(); // Output: // Performing action in ConcreteProductA2 // Performing action in ConcreteProductB2 } } Advantages Provides a consistent interface for creating related objects, separating the responsibility of object creation. Clients can create objects without directly depending on concrete classes. Maintains consistency and compatibility among objects. Allows creating different object configurations by adding new concrete factory Comparison between Factory Pattern and Abstract Factory Pattern As mentioned in the previous article about the Factory pattern, excessive use of the Factory pattern can lead to decreased code readability due to unnecessary branching. The following example demonstrates a case where the excessive use of the Factory pattern affects code readability:\n// Animal interface public interface Animal { void makeSound(); } // Cat class public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Meow\u0026quot;); } } // Dog class public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Woof\u0026quot;); } } // Bird class public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Chirp\u0026quot;); } } // AnimalFactory class for creating Animal objects public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;Cat\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;Dog\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;Bird\u0026quot;)) { return new Bird(); } else if (type.equalsIgnoreCase(\u0026quot;Rabbit\u0026quot;)) { return new Rabbit(); } else if (type.equalsIgnoreCase(\u0026quot;Snake\u0026quot;)) { return new Snake(); } return null; } } // Rabbit class public class Rabbit implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Hop hop\u0026quot;); } } // Snake class public class Snake implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Hiss\u0026quot;); } } // Client code public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;Cat\u0026quot;); cat.makeSound(); // Output: \u0026quot;Meow\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;Dog\u0026quot;); dog.makeSound(); // Output: \u0026quot;Woof\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;Bird\u0026quot;); bird.makeSound(); // Output: \u0026quot;Chirp\u0026quot; Animal rabbit = AnimalFactory.createAnimal(\u0026quot;Rabbit\u0026quot;); rabbit.makeSound(); // Output: \u0026quot;Hop hop\u0026quot; Animal snake = AnimalFactory.createAnimal(\u0026quot;Snake\u0026quot;); snake.makeSound(); // Output: \u0026quot;Hiss\u0026quot; } } By using the Abstract Factory pattern, we can refactor the code as follows:\n// Animal interface public interface Animal { void makeSound(); } // Cat class public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Meow\u0026quot;); } } // Dog class public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Woof\u0026quot;); } } // Bird class public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Chirp\u0026quot;); } } // Abstract Animal Factory public interface AnimalFactory { Animal createAnimal(); } // Cat Factory public class CatFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Cat(); } } // Dog Factory public class DogFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Dog(); } } // Bird Factory public class BirdFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Bird(); } } // Client code public class Client { public static void main(String[] args) { AnimalFactory catFactory = new CatFactory(); Animal cat = catFactory.createAnimal(); cat.makeSound(); // Output: \u0026quot;Meow\u0026quot; AnimalFactory dogFactory = new DogFactory(); Animal dog = dogFactory.createAnimal(); dog.makeSound(); // Output: \u0026quot;Woof\u0026quot; AnimalFactory birdFactory = new BirdFactory(); Animal bird = birdFactory.createAnimal(); bird.makeSound(); // Output: \u0026quot;Chirp\u0026quot; } } Of course, excessive use of the Abstract Factory pattern can lead to similar issues as the Factory pattern, so it\u0026rsquo;s important to use it appropriately based on the given situation and the desired direction of resolution.\nPatterns that complement the Abstract Factory Pattern One pattern that complements the Abstract Factory pattern is the Singleton pattern. By using the Singleton pattern to ensure that the Factory class has a single instance, consistent object creation can be guaranteed.\nThat concludes the article on the Abstract Factory pattern. It also mentions scenarios where it can be used in conjunction with other patterns or situations where it might be misused. I hope this helps!\n","permalink":"https://soulsy.github.io/samtech/dev/design_pattern/abstract_factory_pattern/","title":"Design Pattern 02. Abstract Factory Pattern"},{"content":"The Factory pattern is a design pattern that encapsulates object creation, providing flexibility and extensibility. This pattern allows clients to create and retrieve objects through factory methods instead of directly instantiating them.\nOverview The Factory pattern involves using factory methods to create and return objects, relieving clients from the responsibility of direct object creation. By utilizing factory methods, clients can easily create objects without being aware of the complex object creation logic.\nExample Code // Animal interface public interface Animal { void makeSound(); } // Cat class public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Meow\u0026quot;); } } // Dog class public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Woof\u0026quot;); } } // Bird class public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Tweet\u0026quot;); } } // AnimalFactory class for creating animals public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;Cat\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;Dog\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;Bird\u0026quot;)) { return new Bird(); } return null; } } // Client code public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;Cat\u0026quot;); cat.makeSound(); // Output: \u0026quot;Meow\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;Dog\u0026quot;); dog.makeSound(); // Output: \u0026quot;Woof\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;Bird\u0026quot;); bird.makeSound(); // Output: \u0026quot;Tweet\u0026quot; } } Advantages Encapsulating object creation logic improves code readability and maintainability. The Factory class can be easily extended or modified to add new objects, promoting scalability. Clients delegate the responsibility of object creation to factory methods, reducing dependencies. Common Pitfalls Using the Factory pattern improperly can lead to complex and less maintainable code. Excessive use of factory methods or complex conditional statements can decrease code readability and maintainability. Therefore, it is important to use the Factory pattern in appropriate situations and contexts.\nHere is an example of code that demonstrates how excessive use of factory methods can reduce readability and maintainability:\n// Animal interface public interface Animal { void makeSound(); } // Cat class public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Meow\u0026quot;); } } // Dog class public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Woof\u0026quot;); } } // Bird class public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Tweet\u0026quot;); } } // AnimalFactory class for creating animals public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;Cat\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;Dog\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;Bird\u0026quot;)) { return new Bird(); } else if (type.equalsIgnoreCase(\u0026quot;Rabbit\u0026quot;)) { return new Rabbit(); } else if (type.equalsIgnoreCase(\u0026quot;Snake\u0026quot;)) { return new Snake(); } return null; } } // Rabbit class public class Rabbit implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Hop hop\u0026quot;); } } // Snake class public class Snake implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Ssssss\u0026quot;); } } // Client code public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;Cat\u0026quot;); cat.makeSound(); // Output: \u0026quot;Meow\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;Dog\u0026quot;); dog.makeSound(); // Output: \u0026quot;Woof\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;Bird\u0026quot;); bird.makeSound(); // Output: \u0026quot;Tweet\u0026quot; Animal rabbit = AnimalFactory.createAnimal(\u0026quot;Rabbit\u0026quot;); rabbit.makeSound(); // Output: \u0026quot;Hop hop\u0026quot; Animal snake = AnimalFactory.createAnimal(\u0026quot;Snake\u0026quot;); snake.makeSound(); // Output: \u0026quot;Ssssss\u0026quot; } } In the above example, even though the Factory pattern is used for object creation, the readability is reduced due to excessive use of factory methods. Whenever a new animal is added, the AnimalFactory class\u0026rsquo;s factory method must be modified, which can be cumbersome. In such cases, considering the Abstract Factory pattern, which reduces the usage of factory methods, can be beneficial.\nRelated Patterns to Use An often-used pattern in conjunction with the Factory pattern is the Abstract Factory pattern. The Abstract Factory pattern provides an interface for creating families of related objects, further separating object creation responsibilities.\nAnother pattern commonly used with the Factory pattern is the Singleton pattern. The Singleton pattern ensures a single instance and can be utilized within the factory class for creating a single instance of the factory.\n","permalink":"https://soulsy.github.io/samtech/dev/design_pattern/factory_pattern/","title":"Design Pattern 01. Factory Pattern"},{"content":"Welcome to SamTech, where we delve into various topics and engage in discussions about technology. SamTech represents the number \u0026ldquo;three\u0026rdquo; (Sam in Korean), symbolizing the three key areas we focus on: News, Development, and Knowledge.\nJoin us on this journey of learning and information exchange as we delve into the world of technology together.\nGet ready to embark on an exciting adventure with SamTech. Stay tuned for an enriching experience!\n","permalink":"https://soulsy.github.io/samtech/about/","title":"About"}]