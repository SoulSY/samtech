[{"content":"The Singleton pattern ensures that a class has only one instance of its object and provides a global access point to it.\nOverview of the Singleton Pattern The Singleton pattern has the following characteristics:\nThere is only one instance of the class. It provides a global access point, allowing access to the same instance from anywhere. The Singleton pattern can be useful in various situations and is a commonly used pattern.\nAdvantages of the Singleton Pattern The Singleton pattern offers the following advantages:\nIt minimizes resource usage by ensuring that only one instance exists. It provides easy access to the instance through a global access point. Mistakes in Using the Singleton Pattern Mistakes in using the Singleton pattern can lead to the following problems:\nIn a multi-threaded environment, synchronization issues can arise. If multiple threads request instance creation simultaneously, multiple instances may be created. It can negatively impact testability. Since the Singleton instance is accessed globally and not injected as a dependency, it can be challenging to test. It can violate the Single Responsibility Principle. If the Singleton class includes additional functionality to maintain instance uniqueness, it may take on too many responsibilities. An example of a wrongly implemented Singleton pattern is when multiple threads can create instances concurrently, resulting in multiple instances or inconsistent instance state. Here is an example code demonstrating such an issue:\npublic class BadSingleton { private static BadSingleton instance; private BadSingleton() { // Instance creation logic } public static BadSingleton getInstance() { if (instance == null) { // Multiple threads can simultaneously enter this section instance = new BadSingleton(); } return instance; } // Other methods and data members } In the above code, the getInstance() method can suffer from a race condition where multiple threads enter the section that checks for instance being null simultaneously. This can result in different instances being created.\nTo address this issue, synchronization needs to be implemented. Here is an example of a properly synchronized Singleton pattern code:\npublic class GoodSingleton { private static GoodSingleton instance; private GoodSingleton() { // Instance creation logic } public static synchronized GoodSingleton getInstance() { if (instance == null) { instance = new GoodSingleton(); } return instance; } // Other methods and data members } In the above code, the getInstance() method is synchronized using the synchronized keyword. This prevents multiple threads from simultaneously accessing the method, ensuring that only one thread creates the instance.\nWhen used correctly, the Singleton pattern ensures safe usage in a multi-threaded environment. However, it is important to exercise caution and use the pattern only when necessary.\nPatterns That Work Well with the Singleton Pattern A pattern that works well with the Singleton pattern is the Abstract Factory pattern. By applying the Singleton pattern to the factory class, you can ensure consistent object creation.\nHere is an example code demonstrating the combination of the Singleton pattern and the Abstract Factory pattern:\n// SingletonFactory with Singleton pattern for Abstract Factory public class SingletonFactory implements AbstractFactory { private static SingletonFactory instance; private SingletonFactory() { // Instance creation logic } public static synchronized SingletonFactory getInstance() { if (instance == null) { instance = new SingletonFactory(); } return instance; } public AbstractProductA createProductA() { return new ConcreteProductA(); } public AbstractProductB createProductB() { return new ConcreteProductB(); } } // Abstract Factory interface public interface AbstractFactory { AbstractProductA createProductA(); AbstractProductB createProductB(); } // Concrete product classes public class ConcreteProductA implements AbstractProductA { // Implementation of Product A } public class ConcreteProductB implements AbstractProductB { // Implementation of Product B } In the above example, the SingletonFactory class implements the AbstractFactory interface using the Singleton pattern. The SingletonFactory instance is maintained as a single instance according to the Singleton pattern, and the createProductA and createProductB methods create objects.\nBy combining the Singleton pattern with the Abstract Factory pattern in this way, the Singleton pattern ensures that the concrete factory class\u0026rsquo;s instance remains unique, allowing consistent object creation.\nI hope this provides a better understanding of the Singleton pattern and its correct usage. Let me know if you have any further questions!\n","permalink":"https://soulsy.github.io/samtech/dev/design_pattern/singleton_pattern/","title":"Design Pattern 03. Singleton Pattern"},{"content":"The Abstract Factory pattern is a design pattern that provides an interface for creating related objects, separating the responsibility of object creation. This pattern is useful when multiple objects that are related to each other need to be created, and it allows creating objects without depending on specific classes.\nOverview of the Abstract Factory Pattern The Abstract Factory pattern allows clients to create objects through an abstract factory interface instead of directly creating them. The abstract factory provides an interface for a set of related objects, and concrete factory classes implement this interface to create actual objects. This allows clients to create objects without directly depending on concrete classes.\nExample Code // Abstract Product A public interface AbstractProductA { void performAction(); } // Abstract Product B public interface AbstractProductB { void performAction(); } // Concrete Product A1 public class ConcreteProductA1 implements AbstractProductA { @Override public void performAction() { System.out.println(\u0026quot;Performing action in ConcreteProductA1\u0026quot;); } } // Concrete Product A2 public class ConcreteProductA2 implements AbstractProductA { @Override public void performAction() { System.out.println(\u0026quot;Performing action in ConcreteProductA2\u0026quot;); } } // Concrete Product B1 public class ConcreteProductB1 implements AbstractProductB { @Override public void performAction() { System.out.println(\u0026quot;Performing action in ConcreteProductB1\u0026quot;); } } // Concrete Product B2 public class ConcreteProductB2 implements AbstractProductB { @Override public void performAction() { System.out.println(\u0026quot;Performing action in ConcreteProductB2\u0026quot;); } } // Abstract Factory interface public interface AbstractFactory { AbstractProductA createProductA(); AbstractProductB createProductB(); } // Concrete Factory A public class ConcreteFactoryA implements AbstractFactory { @Override public AbstractProductA createProductA() { return new ConcreteProductA1(); } @Override public AbstractProductB createProductB() { return new ConcreteProductB1(); } } // Concrete Factory B public class ConcreteFactoryB implements AbstractFactory { @Override public AbstractProductA createProductA() { return new ConcreteProductA2(); } @Override public AbstractProductB createProductB() { return new ConcreteProductB2(); } } // Client code public class Client { private AbstractProductA productA; private AbstractProductB productB; public Client(AbstractFactory factory) { productA = factory.createProductA(); productB = factory.createProductB(); } public void performActions() { productA.performAction(); productB.performAction(); } public static void main(String[] args) { AbstractFactory factoryA = new ConcreteFactoryA(); Client clientA = new Client(factoryA); clientA.performActions(); // Output: // Performing action in ConcreteProductA1 // Performing action in ConcreteProductB1 AbstractFactory factoryB = new ConcreteFactoryB(); Client clientB = new Client(factoryB); clientB.performActions(); // Output: // Performing action in ConcreteProductA2 // Performing action in ConcreteProductB2 } } Advantages of the Abstract Factory Pattern Provides a consistent interface for creating related objects, separating the responsibility of object creation. Clients can create objects without directly depending on concrete classes. Maintains consistency and compatibility among objects. Allows creating different object configurations by adding new concrete factory Comparison between Factory Pattern and Abstract Factory Pattern As mentioned in the previous article about the Factory pattern, excessive use of the Factory pattern can lead to decreased code readability due to unnecessary branching. The following example demonstrates a case where the excessive use of the Factory pattern affects code readability:\n// Animal interface public interface Animal { void makeSound(); } // Cat class public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Meow\u0026quot;); } } // Dog class public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Woof\u0026quot;); } } // Bird class public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Chirp\u0026quot;); } } // AnimalFactory class for creating Animal objects public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;Cat\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;Dog\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;Bird\u0026quot;)) { return new Bird(); } else if (type.equalsIgnoreCase(\u0026quot;Rabbit\u0026quot;)) { return new Rabbit(); } else if (type.equalsIgnoreCase(\u0026quot;Snake\u0026quot;)) { return new Snake(); } return null; } } // Rabbit class public class Rabbit implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Hop hop\u0026quot;); } } // Snake class public class Snake implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Hiss\u0026quot;); } } // Client code public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;Cat\u0026quot;); cat.makeSound(); // Output: \u0026quot;Meow\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;Dog\u0026quot;); dog.makeSound(); // Output: \u0026quot;Woof\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;Bird\u0026quot;); bird.makeSound(); // Output: \u0026quot;Chirp\u0026quot; Animal rabbit = AnimalFactory.createAnimal(\u0026quot;Rabbit\u0026quot;); rabbit.makeSound(); // Output: \u0026quot;Hop hop\u0026quot; Animal snake = AnimalFactory.createAnimal(\u0026quot;Snake\u0026quot;); snake.makeSound(); // Output: \u0026quot;Hiss\u0026quot; } } By using the Abstract Factory pattern, we can refactor the code as follows:\n// Animal interface public interface Animal { void makeSound(); } // Cat class public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Meow\u0026quot;); } } // Dog class public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Woof\u0026quot;); } } // Bird class public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Chirp\u0026quot;); } } // Abstract Animal Factory public interface AnimalFactory { Animal createAnimal(); } // Cat Factory public class CatFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Cat(); } } // Dog Factory public class DogFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Dog(); } } // Bird Factory public class BirdFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Bird(); } } // Client code public class Client { public static void main(String[] args) { AnimalFactory catFactory = new CatFactory(); Animal cat = catFactory.createAnimal(); cat.makeSound(); // Output: \u0026quot;Meow\u0026quot; AnimalFactory dogFactory = new DogFactory(); Animal dog = dogFactory.createAnimal(); dog.makeSound(); // Output: \u0026quot;Woof\u0026quot; AnimalFactory birdFactory = new BirdFactory(); Animal bird = birdFactory.createAnimal(); bird.makeSound(); // Output: \u0026quot;Chirp\u0026quot; } } Of course, excessive use of the Abstract Factory pattern can lead to similar issues as the Factory pattern, so it\u0026rsquo;s important to use it appropriately based on the given situation and the desired direction of resolution.\nPatterns that complement the Abstract Factory Pattern One pattern that complements the Abstract Factory pattern is the Singleton pattern. By using the Singleton pattern to ensure that the Factory class has a single instance, consistent object creation can be guaranteed.\nThat concludes the article on the Abstract Factory pattern. It also mentions scenarios where it can be used in conjunction with other patterns or situations where it might be misused. I hope this helps!\n","permalink":"https://soulsy.github.io/samtech/dev/design_pattern/abstract_design_pattern/","title":"Design Pattern 02. Abstract Factory Pattern"},{"content":"The Factory pattern is a design pattern that encapsulates object creation, providing flexibility and extensibility. This pattern allows clients to create and retrieve objects through factory methods instead of directly instantiating them.\nOverview of the Factory Pattern The Factory pattern involves using factory methods to create and return objects, relieving clients from the responsibility of direct object creation. By utilizing factory methods, clients can easily create objects without being aware of the complex object creation logic.\nExample Code // Animal interface public interface Animal { void makeSound(); } // Cat class public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Meow\u0026quot;); } } // Dog class public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Woof\u0026quot;); } } // Bird class public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Tweet\u0026quot;); } } // AnimalFactory class for creating animals public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;Cat\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;Dog\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;Bird\u0026quot;)) { return new Bird(); } return null; } } // Client code public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;Cat\u0026quot;); cat.makeSound(); // Output: \u0026quot;Meow\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;Dog\u0026quot;); dog.makeSound(); // Output: \u0026quot;Woof\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;Bird\u0026quot;); bird.makeSound(); // Output: \u0026quot;Tweet\u0026quot; } } Advantages of the Factory Pattern Encapsulating object creation logic improves code readability and maintainability. The Factory class can be easily extended or modified to add new objects, promoting scalability. Clients delegate the responsibility of object creation to factory methods, reducing dependencies. Common Pitfalls of Using the Factory Pattern Using the Factory pattern improperly can lead to complex and less maintainable code. Excessive use of factory methods or complex conditional statements can decrease code readability and maintainability. Therefore, it is important to use the Factory pattern in appropriate situations and contexts.\nHere is an example of code that demonstrates how excessive use of factory methods can reduce readability and maintainability:\n// Animal interface public interface Animal { void makeSound(); } // Cat class public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Meow\u0026quot;); } } // Dog class public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Woof\u0026quot;); } } // Bird class public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Tweet\u0026quot;); } } // AnimalFactory class for creating animals public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;Cat\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;Dog\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;Bird\u0026quot;)) { return new Bird(); } else if (type.equalsIgnoreCase(\u0026quot;Rabbit\u0026quot;)) { return new Rabbit(); } else if (type.equalsIgnoreCase(\u0026quot;Snake\u0026quot;)) { return new Snake(); } return null; } } // Rabbit class public class Rabbit implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Hop hop\u0026quot;); } } // Snake class public class Snake implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;Ssssss\u0026quot;); } } // Client code public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;Cat\u0026quot;); cat.makeSound(); // Output: \u0026quot;Meow\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;Dog\u0026quot;); dog.makeSound(); // Output: \u0026quot;Woof\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;Bird\u0026quot;); bird.makeSound(); // Output: \u0026quot;Tweet\u0026quot; Animal rabbit = AnimalFactory.createAnimal(\u0026quot;Rabbit\u0026quot;); rabbit.makeSound(); // Output: \u0026quot;Hop hop\u0026quot; Animal snake = AnimalFactory.createAnimal(\u0026quot;Snake\u0026quot;); snake.makeSound(); // Output: \u0026quot;Ssssss\u0026quot; } } In the above example, even though the Factory pattern is used for object creation, the readability is reduced due to excessive use of factory methods. Whenever a new animal is added, the AnimalFactory class\u0026rsquo;s factory method must be modified, which can be cumbersome. In such cases, considering the Abstract Factory pattern, which reduces the usage of factory methods, can be beneficial.\nRelated Patterns to Use with the Factory Pattern An often-used pattern in conjunction with the Factory pattern is the Abstract Factory pattern. The Abstract Factory pattern provides an interface for creating families of related objects, further separating object creation responsibilities.\nAnother pattern commonly used with the Factory pattern is the Singleton pattern. The Singleton pattern ensures a single instance and can be utilized within the factory class for creating a single instance of the factory.\n","permalink":"https://soulsy.github.io/samtech/dev/design_pattern/faactory_pattern/","title":"Design Pattern 01. Factory Pattern"},{"content":"Welcome to SamTech, where we delve into various topics and engage in discussions about technology. SamTech represents the number \u0026ldquo;three\u0026rdquo; (Sam in Korean), symbolizing the three key areas we focus on: News, Development, and Knowledge.\nJoin us on this journey of learning and information exchange as we delve into the world of technology together.\nGet ready to embark on an exciting adventure with SamTech. Stay tuned for an enriching experience!\n","permalink":"https://soulsy.github.io/samtech/about/","title":"About"}]