[{"content":"Singleton 패턴은 클래스의 인스턴스가 단일하게 유지되도록 보장하는 디자인 패턴입니다. 이 패턴은 어떤 클래스의 인스턴스가 하나만 존재하고, 이를 전역적으로 접근할 수 있는 방법을 제공합니다.\nSingleton 패턴의 개요 Singleton 패턴은 다음과 같은 특징을 가집니다:\n클래스의 인스턴스가 오직 하나만 존재합니다. 전역적으로 접근 가능한 접근점을 제공하여 어디서든 동일한 인스턴스에 접근할 수 있습니다. Singleton 패턴은 다양한 상황에서 유용하게 사용될 수 있으며, 자주 사용되는 패턴 중 하나입니다.\nSingleton 패턴의 장점 Singleton 패턴은 다음과 같은 장점을 가집니다:\n하나의 인스턴스만 존재하므로, 자원의 낭비를 줄일 수 있습니다. 전역적인 접근점을 통해 인스턴스에 접근할 수 있으므로, 간편한 사용이 가능합니다. Singleton 패턴을 잘못 사용하는 경우 Singleton 패턴을 잘못 사용하면 다음과 같은 문제가 발생할 수 있습니다:\n멀티스레드 환경에서 동기화 문제가 발생할 수 있습니다. 동시에 여러 스레드가 인스턴스 생성을 요청할 경우, 여러 인스턴스가 생성될 수 있습니다. 테스트 용이성이 저하될 수 있습니다. Singleton 인스턴스가 의존성으로 주입되지 않고 전역적으로 사용되기 때문에 테스트하기 어려울 수 있습니다. 단일 책임 원칙(Single Responsibility Principle)에 위배될 수 있습니다. Singleton 클래스가 다른 기능을 포함하면서 인스턴스 유일성을 유지하기 위한 코드가 추가될 경우, 클래스의 책임이 너무 많아질 수 있습니다. 잘못된 Singleton 패턴은 다음과 같은 문제를 일으킬 수 있습니다. 여러 스레드가 동시에 인스턴스를 생성할 수 있어서 여러 인스턴스가 생성되거나, 인스턴스의 일관성을 보장할 수 없는 경우입니다. 아래는 이러한 문제가 발생하는 잘못된 Singleton 패턴의 예시 코드입니다.\npublic class BadSingleton { private static BadSingleton instance; private BadSingleton() { // 인스턴스 생성 로직 } public static BadSingleton getInstance() { if (instance == null) { // 여러 스레드가 동시에 이 부분에 진입할 수 있음 instance = new BadSingleton(); } return instance; } // 기타 기능 및 데이터 멤버 } 위의 코드에서 getInstance() 메서드는 여러 스레드가 동시에 인스턴스를 생성할 수 있는 문제가 있습니다. 여러 스레드가 동시에 instance가 null인 것을 확인하고 인스턴스를 생성하게 되면, 서로 다른 인스턴스가 생성될 수 있습니다.\n이러한 상황에서는 동기화(synchronization) 문제를 해결해야 합니다. 아래는 동기화를 추가하여 올바르게 동작하는 Singleton 패턴의 예시 코드입니다.\npublic class GoodSingleton { private static GoodSingleton instance; private GoodSingleton() { // 인스턴스 생성 로직 } public static synchronized GoodSingleton getInstance() { if (instance == null) { instance = new GoodSingleton(); } return instance; } // 기타 기능 및 데이터 멤버 } 위의 코드에서 getInstance() 메서드에 synchronized 키워드를 추가하여 동기화하였습니다. 이를 통해 여러 스레드가 동시에 getInstance() 메서드에 접근하는 것을 방지하고, 하나의 스레드만이 인스턴스를 생성할 수 있도록 보장합니다.\n올바르게 동작하는 Singleton 패턴은 멀티스레드 환경에서 안전하게 사용할 수 있습니다. 하지만 Singleton 패턴을 사용할 때는 주의해야 하며, 필요한 경우에만 사용하는 것이 좋습니다.\nSingleton 패턴과 함께 사용하면 좋은 패턴 Singleton 패턴과 함께 사용하면 좋은 패턴으로는 Abstract Factory 패턴이 있습니다. Abstract Factory 패턴을 사용하여 Singleton 패턴으로 생성된 인스턴스를 활용할 수 있습니다. Singleton 패턴을 적용하여 팩토리 클래스의 인스턴스가 단일하게 유지되면, 일관된 객체 생성을 보장할 수 있습니다.\n아래는 Singleton 패턴과 Abstract Factory 패턴을 함께 사용하는 예제 코드입니다.\n// Singleton 패턴을 적용한 팩토 리 클래스 public class SingletonFactory implements AbstractFactory { private static SingletonFactory instance; private SingletonFactory() { // 인스턴스 생성 로직 } public static synchronized SingletonFactory getInstance() { if (instance == null) { instance = new SingletonFactory(); } return instance; } public AbstractProductA createProductA() { return new ConcreteProductA(); } public AbstractProductB createProductB() { return new ConcreteProductB(); } } // Abstract Factory 패턴을 위한 인터페이스 public interface AbstractFactory { AbstractProductA createProductA(); AbstractProductB createProductB(); } // 구체적인 제품 클래스 public class ConcreteProductA implements AbstractProductA { // 제품 A의 구현 } public class ConcreteProductB implements AbstractProductB { // 제품 B의 구현 } 위의 예제 코드에서 Singleton 패턴을 적용한 SingletonFactory 클래스는 AbstractFactory 인터페이스를 구현합니다. SingletonFactory 클래스의 인스턴스는 Singleton 패턴에 따라 단일하게 유지되며, createProductA 및 createProductB 메서드를 통해 객체를 생성합니다.\n이렇게 함께 사용되는 경우, Singleton 패턴을 통해 Abstract Factory 패턴의 구체 팩토리 클래스의 인스턴스가 단일하게 유지되므로, 일관된 객체 생성이 가능해집니다.\n","permalink":"https://soulsy.github.io/samtech/ko/dev/design_pattern/singleton_pattern/","title":"디자인 패턴 03. Singleton Pattern"},{"content":"Abstract Factory 패턴은 관련된 객체들을 생성하는 인터페이스를 제공하여 객체 생성에 대한 책임을 분리하는 디자인 패턴입니다. 이 패턴은 서로 연관된 다수의 객체를 생성해야 할 때 유용하며, 구체적인 클래스에 의존하지 않고 객체를 생성할 수 있도록 합니다.\nAbstract Factory 패턴의 개요 Abstract Factory 패턴은 클라이언트가 객체를 생성하는 대신, 추상 팩토리 인터페이스를 통해 관련 객체들을 생성합니다. 추상 팩토리는 관련된 객체들의 집합에 대한 인터페이스를 제공하며, 구체적인 팩토리 클래스는 이 인터페이스를 구현하여 실제 객체를 생성합니다. 이를 통해 클라이언트는 구체적인 클래스에 직접 의존하지 않고도 객체를 생성할 수 있습니다.\n예제 코드 // 추상 제품 A public interface AbstractProductA { void performAction(); } // 추상 제품 B public interface AbstractProductB { void performAction(); } // 구체적인 제품 A1 public class ConcreteProductA1 implements AbstractProductA { @Override public void performAction() { System.out.println(\u0026quot;ConcreteProductA1에서 동작 수행\u0026quot;); } } // 구체적인 제품 A2 public class ConcreteProductA2 implements AbstractProductA { @Override public void performAction() { System.out.println(\u0026quot;ConcreteProductA2에서 동작 수행\u0026quot;); } } // 구체적인 제품 B1 public class ConcreteProductB1 implements AbstractProductB { @Override public void performAction() { System.out.println(\u0026quot;ConcreteProductB1에서 동작 수행\u0026quot;); } } // 구체적인 제품 B2 public class ConcreteProductB2 implements AbstractProductB { @Override public void performAction() { System.out.println(\u0026quot;ConcreteProductB2에서 동작 수행\u0026quot;); } } // 추상 팩토리 인터페이스 public interface AbstractFactory { AbstractProductA createProductA(); AbstractProductB createProductB(); } // 구체적인 팩토리 A public class ConcreteFactoryA implements AbstractFactory { @Override public AbstractProductA createProductA() { return new ConcreteProductA1(); } @Override public AbstractProductB createProductB() { return new ConcreteProductB1(); } } // 구체적인 팩토리 B public class ConcreteFactoryB implements AbstractFactory { @Override public AbstractProductA createProductA() { return new ConcreteProductA2(); } @Override public AbstractProductB createProductB() { return new ConcreteProductB2(); } } // 클라이언트 코드 public class Client { private AbstractProductA productA; private AbstractProductB productB; public Client(AbstractFactory factory) { productA = factory.createProductA(); productB = factory.createProductB(); } public void performActions() { productA.performAction(); productB.performAction(); } public static void main(String[] args) { AbstractFactory factoryA = new ConcreteFactoryA(); Client clientA = new Client(factoryA); clientA.performActions(); // 출력: // ConcreteProductA1에서 동작 수행 // ConcreteProductB1에서 동작 수행 AbstractFactory factoryB = new ConcreteFactoryB(); Client clientB = new Client(factoryB); clientB.performActions(); // 출력: // ConcreteProductA2에서 동작 수행 // ConcreteProductB2에서 동작 수행 } } Abstract Factory 패턴의 장점 관련된 객체들을 생성하기 위한 일관된 인터페이스를 제공하여 객체 생성에 대한 책임을 분리합니다. 클라이언트는 구체적인 클래스에 직접 의존하지 않고도 객체를 생성할 수 있습니다. 객체들의 일관성과 호환성을 유지할 수 있습니다. 새로운 구체 팩토리 클래스를 추가하여 다양한 객체 구성을 생성할 수 있습니다. Factory 패턴과 Abstract Factory 패턴 비교 앞서 Factory 패턴의 글에서 말했던 것처럼 과도한 Factory 패턴의 사용이 불필요한 분기문으로 가독성이 떨어지는 상황이 발생할 수 있습니다. 아래 예제는 Factory 패턴의 과한 사용으로 코드 가독성이 떨어지는 예제입니다.\n// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;야옹\u0026quot;); } } // 개 클래스 public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;멍멍\u0026quot;); } } // 새 클래스 public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;짹짹\u0026quot;); } } // Animal을 생성하는 AnimalFactory 클래스 public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;고양이\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;개\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;새\u0026quot;)) { return new Bird(); } else if (type.equalsIgnoreCase(\u0026quot;토끼\u0026quot;)) { return new Rabbit(); } else if (type.equalsIgnoreCase(\u0026quot;뱀\u0026quot;)) { return new Snake(); } return null; } } // 토끼 클래스 public class Rabbit implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;깡총깡총\u0026quot;); } } // 뱀 클래스 public class Snake implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;실실\u0026quot;); } } // 클라이언트 코드 public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;고양이\u0026quot;); cat.makeSound(); // 출력: \u0026quot;야옹\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;개\u0026quot;); dog.makeSound(); // 출력: \u0026quot;멍멍\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;새\u0026quot;); bird.makeSound(); // 출력: \u0026quot;짹짹\u0026quot; Animal rabbit = AnimalFactory.createAnimal(\u0026quot;토끼\u0026quot;); rabbit.makeSound(); // 출력: \u0026quot;깡총깡총\u0026quot; Animal snake = AnimalFactory.createAnimal(\u0026quot;뱀\u0026quot;); snake.makeSound(); // 출력: \u0026quot;실실\u0026quot; } } Abstract Factory 패턴을 사용하면 아래와 같이 리팩토링을 진행해 볼 수 있습니다.\n// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;야옹\u0026quot;); } } // 개 클래스 public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;멍멍\u0026quot;); } } // 새 클래스 public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;짹짹\u0026quot;); } } // 추상 동물 팩토리 public interface AnimalFactory { Animal createAnimal(); } // 고양이 팩토리 public class CatFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Cat(); } } // 개 팩토리 public class DogFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Dog(); } } // 새 팩토리 public class BirdFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Bird(); } } // 클라이언트 코드 public class Client { public static void main(String[] args) { AnimalFactory catFactory = new CatFactory(); Animal cat = catFactory.createAnimal(); cat.makeSound(); // 출력: \u0026quot;야옹\u0026quot; AnimalFactory dogFactory = new DogFactory(); Animal dog = dogFactory.createAnimal(); dog.makeSound(); // 출력: \u0026quot;멍멍\u0026quot; AnimalFactory birdFactory = new BirdFactory(); Animal bird = birdFactory.createAnimal(); bird.makeSound(); // 출력: \u0026quot;짹짹\u0026quot; } } 물론 Abstract Factory 패턴도 과도하게 사용하면 Factory 패턴과 마찬가지로 부작용이 생길 수 있으니 항상 주어진 상황과 해결하려는 방향에 맞게 적절하게 사용함을 기억해야 합니다.\nAbstract Factory 패턴과 함께 사용되는 패턴 Abstract Factory 패턴과 함께 사용하면 좋은 패턴으로는 Singleton 패턴이 있습니다. Singleton 패턴을 사용하여 팩토리 클래스의 인스턴스가 단일하게 유지되도록 함으로써, 일관된 객체 생성을 보장할 수 있습니다.\n이상으로 Abstract Factory 패턴에 대한 내용을 정리한 글입니다. 다른 패턴들과 함께 사용되거나 잘못 사용될 수 있는 경우 등에 대해서도 언급하였습니다. 이 글이 도움이 되기를 바랍니다.\n","permalink":"https://soulsy.github.io/samtech/ko/dev/design_pattern/abstract_faactory_pattern/","title":"디자인 패턴 02. Abstract Factory Pattern"},{"content":"Factory 패턴은 객체 생성을 캡슐화하여 유연성과 확장성을 제공하는 디자인 패턴입니다. 이 패턴은 클라이언트에게 직접 객체 생성을 맡기지 않고, 팩토리 메서드를 통해 객체를 생성하고 반환하는 방식을 사용합니다.\nFactory 패턴의 개요 Factory 패턴은 클라이언트가 객체를 생성하는 대신, 팩토리 메서드를 호출하여 객체를 생성하고 반환합니다. 이를 통해 클라이언트는 객체 생성과 관련된 복잡한 로직을 알 필요 없이, 팩토리 메서드를 통해 쉽게 객체를 생성할 수 있습니다.\n// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;야옹\u0026quot;); } } // 개 클래스 public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;멍멍\u0026quot;); } } // 새 클래스 public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;짹짹\u0026quot;); } } // Animal을 생성하는 AnimalFactory 클래스 public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;고양이\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;개\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;새\u0026quot;)) { return new Bird(); } return null; } } // 클라이언트 코드 public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;고양이\u0026quot;); cat.makeSound(); // 출력: \u0026quot;야옹\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;개\u0026quot;); dog.makeSound(); // 출력: \u0026quot;멍멍\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;새\u0026quot;); bird.makeSound(); // 출력: \u0026quot;짹짹\u0026quot; } } Factory 패턴의 장점 객체 생성 로직을 캡슐화하여 코드의 가독성과 유지보수성을 향상시킵니다. 새로운 객체를 추가하거나 기존 객체를 변경할 때, Factory 클래스의 팩토리 메서드만 수정하면 되므로 확장성이 좋습니다. 클라이언트는 객체 생성에 대한 결정을 팩토리 메서드에 위임함으로써 의존성을 낮출 수 있습니다. Factory 패턴을 잘못 사용하는 경우 Factory 패턴을 잘못 사용하면 코드가 복잡해질 수 있습니다. 과도한 팩토리 메서드의 사용이나 복잡한 조건문으로 인해 코드의 가독성과 유지보수성이 저하될 수 있습니다. 따라서, 적절한 상황과 용도에서 Factory 패턴을 사용해야 합니다.\n과도한 팩토리 메서드 사용으로 가독성과 유지보수성이 저하되는 예제 코드를 보여드리겠습니다:\n// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;야옹\u0026quot;); } } // 개 클래스 public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;멍멍\u0026quot;); } } // 새 클래스 public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;짹짹\u0026quot;); } } // Animal을 생성하는 AnimalFactory 클래스 public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;고양이\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;개\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;새\u0026quot;)) { return new Bird(); } else if (type.equalsIgnoreCase(\u0026quot;토끼\u0026quot;)) { return new Rabbit(); } else if (type.equalsIgnoreCase(\u0026quot;뱀\u0026quot;)) { return new Snake(); } return null; } } // 토끼 클래스 public class Rabbit implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;깡총깡총\u0026quot;); } } // 뱀 클래스 public class Snake implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;실실\u0026quot;); } } // 클라이언트 코드 public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;고양이\u0026quot;); cat.makeSound(); // 출력: \u0026quot;야옹\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;개\u0026quot;); dog.makeSound(); // 출력: \u0026quot;멍멍\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;새\u0026quot;); bird.makeSound(); // 출력: \u0026quot;짹짹\u0026quot; Animal rabbit = AnimalFactory.createAnimal(\u0026quot;토끼\u0026quot;); rabbit.makeSound(); // 출력: \u0026quot;깡총깡총\u0026quot; Animal snake = AnimalFactory.createAnimal(\u0026quot;뱀\u0026quot;); snake.makeSound(); // 출력: \u0026quot;실실\u0026quot; } } 위의 예제에서는 Factory 패턴을 사용하여 객체를 생성하고 있지만, 팩토리 메서드의 분기문이 많아져 가독성이 저하됩니다. 새로운 동물을 추가할 때마다 AnimalFactory 클래스의 팩토리 메서드를 수정해야 하는 번거로움이 있습니다. 이러한 상황에서는 팩토리 메서드의 사용을 줄이고, 추상 팩토리 패턴을 고려하는 것이 도움이 됩니다.\nFactory 패턴과 함께 사용되는 패턴 Factory 패턴과 함께 사용하면 좋은 패턴은 추상 팩토리(Abstract Factory) 패턴입니다. 추상 팩토리 패턴은 관련된 객체들을 생성하는 인터페이스를 제공하여 객체 생성에 대한 책임을 분리합니다.\nFactory 패턴과 함께 자주 등장하는 패턴으로는 Singleton 패턴이 있습니다. Singleton 패턴은 단일 인스턴스를 보장하고, 팩토리 클래스 내에서 단일 인스턴스를 생성할 수 있습니다.\n","permalink":"https://soulsy.github.io/samtech/ko/dev/design_pattern/faactory_pattern/","title":"디자인 패턴 01. Factory Pattern"},{"content":"삼테크에 오신 것을 환영합니다. 삼테크는 다양한 주제를 다루며 기술에 대한 토론을 진행하는 곳입니다. 삼테크라는 이름에 걸맞게 세 가지 주요 분야(News, Development, Knowledge)에 대해 다룹니다.\n삼테크는 보안 관련 주제도 다루지만, 주로 다양한 기술, 개발 및 IT 동향에 초점을 맞추고 있습니다. 우리는 기술 열정을 자유롭게 탐구하고 공유할 수 있는 플랫폼을 제공합니다. 함께 학습하고 정보를 교류하는 이 여정에 참여해보세요.\n","permalink":"https://soulsy.github.io/samtech/ko/about/","title":"About"}]