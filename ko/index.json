[{"content":"Abstract Factory 패턴은 관련된 객체들을 생성하는 인터페이스를 제공하여 객체 생성에 대한 책임을 분리하는 디자인 패턴입니다. 이 패턴은 서로 연관된 다수의 객체를 생성해야 할 때 유용하며, 구체적인 클래스에 의존하지 않고 객체를 생성할 수 있도록 합니다.\nAbstract Factory 패턴의 개요 Abstract Factory 패턴은 클라이언트가 객체를 생성하는 대신, 추상 팩토리 인터페이스를 통해 관련 객체들을 생성합니다. 추상 팩토리는 관련된 객체들의 집합에 대한 인터페이스를 제공하며, 구체적인 팩토리 클래스는 이 인터페이스를 구현하여 실제 객체를 생성합니다. 이를 통해 클라이언트는 구체적인 클래스에 직접 의존하지 않고도 객체를 생성할 수 있습니다.\n예제 코드 // 추상 제품 A public interface AbstractProductA { void performAction(); } // 추상 제품 B public interface AbstractProductB { void performAction(); } // 구체적인 제품 A1 public class ConcreteProductA1 implements AbstractProductA { @Override public void performAction() { System.out.println(\u0026quot;ConcreteProductA1에서 동작 수행\u0026quot;); } } // 구체적인 제품 A2 public class ConcreteProductA2 implements AbstractProductA { @Override public void performAction() { System.out.println(\u0026quot;ConcreteProductA2에서 동작 수행\u0026quot;); } } // 구체적인 제품 B1 public class ConcreteProductB1 implements AbstractProductB { @Override public void performAction() { System.out.println(\u0026quot;ConcreteProductB1에서 동작 수행\u0026quot;); } } // 구체적인 제품 B2 public class ConcreteProductB2 implements AbstractProductB { @Override public void performAction() { System.out.println(\u0026quot;ConcreteProductB2에서 동작 수행\u0026quot;); } } // 추상 팩토리 인터페이스 public interface AbstractFactory { AbstractProductA createProductA(); AbstractProductB createProductB(); } // 구체적인 팩토리 A public class ConcreteFactoryA implements AbstractFactory { @Override public AbstractProductA createProductA() { return new ConcreteProductA1(); } @Override public AbstractProductB createProductB() { return new ConcreteProductB1(); } } // 구체적인 팩토리 B public class ConcreteFactoryB implements AbstractFactory { @Override public AbstractProductA createProductA() { return new ConcreteProductA2(); } @Override public AbstractProductB createProductB() { return new ConcreteProductB2(); } } // 클라이언트 코드 public class Client { private AbstractProductA productA; private AbstractProductB productB; public Client(AbstractFactory factory) { productA = factory.createProductA(); productB = factory.createProductB(); } public void performActions() { productA.performAction(); productB.performAction(); } public static void main(String[] args) { AbstractFactory factoryA = new ConcreteFactoryA(); Client clientA = new Client(factoryA); clientA.performActions(); // 출력: // ConcreteProductA1에서 동작 수행 // ConcreteProductB1에서 동작 수행 AbstractFactory factoryB = new ConcreteFactoryB(); Client clientB = new Client(factoryB); clientB.performActions(); // 출력: // ConcreteProductA2에서 동작 수행 // ConcreteProductB2에서 동작 수행 } } Abstract Factory 패턴의 장점 관련된 객체들을 생성하기 위한 일관된 인터페이스를 제공하여 객체 생성에 대한 책임을 분리합니다. 클라이언트는 구체적인 클래스에 직접 의존하지 않고도 객체를 생성할 수 있습니다. 객체들의 일관성과 호환성을 유지할 수 있습니다. 새로운 구체 팩토리 클래스를 추가하여 다양한 객체 구성을 생성할 수 있습니다. Factory 패턴과 Abstract Factory 패턴 비교 앞서 Factory 패턴의 글에서 말했던 것처럼 과도한 Factory 패턴의 사용이 불필요한 분기문으로 가독성이 떨어지는 상황이 발생할 수 있습니다. 아래 예제는 Factory 패턴의 과한 사용으로 코드 가독성이 떨어지는 예제입니다.\n// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;야옹\u0026quot;); } } // 개 클래스 public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;멍멍\u0026quot;); } } // 새 클래스 public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;짹짹\u0026quot;); } } // Animal을 생성하는 AnimalFactory 클래스 public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;고양이\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;개\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;새\u0026quot;)) { return new Bird(); } else if (type.equalsIgnoreCase(\u0026quot;토끼\u0026quot;)) { return new Rabbit(); } else if (type.equalsIgnoreCase(\u0026quot;뱀\u0026quot;)) { return new Snake(); } return null; } } // 토끼 클래스 public class Rabbit implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;깡총깡총\u0026quot;); } } // 뱀 클래스 public class Snake implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;실실\u0026quot;); } } // 클라이언트 코드 public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;고양이\u0026quot;); cat.makeSound(); // 출력: \u0026quot;야옹\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;개\u0026quot;); dog.makeSound(); // 출력: \u0026quot;멍멍\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;새\u0026quot;); bird.makeSound(); // 출력: \u0026quot;짹짹\u0026quot; Animal rabbit = AnimalFactory.createAnimal(\u0026quot;토끼\u0026quot;); rabbit.makeSound(); // 출력: \u0026quot;깡총깡총\u0026quot; Animal snake = AnimalFactory.createAnimal(\u0026quot;뱀\u0026quot;); snake.makeSound(); // 출력: \u0026quot;실실\u0026quot; } } Abstract Factory 패턴을 사용하면 아래와 같이 리팩토링을 진행해 볼 수 있습니다.\n// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;야옹\u0026quot;); } } // 개 클래스 public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;멍멍\u0026quot;); } } // 새 클래스 public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;짹짹\u0026quot;); } } // 추상 동물 팩토리 public interface AnimalFactory { Animal createAnimal(); } // 고양이 팩토리 public class CatFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Cat(); } } // 개 팩토리 public class DogFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Dog(); } } // 새 팩토리 public class BirdFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Bird(); } } // 클라이언트 코드 public class Client { public static void main(String[] args) { AnimalFactory catFactory = new CatFactory(); Animal cat = catFactory.createAnimal(); cat.makeSound(); // 출력: \u0026quot;야옹\u0026quot; AnimalFactory dogFactory = new DogFactory(); Animal dog = dogFactory.createAnimal(); dog.makeSound(); // 출력: \u0026quot;멍멍\u0026quot; AnimalFactory birdFactory = new BirdFactory(); Animal bird = birdFactory.createAnimal(); bird.makeSound(); // 출력: \u0026quot;짹짹\u0026quot; } } 물론 Abstract Factory 패턴도 과도하게 사용하면 Factory 패턴과 마찬가지로 부작용이 생길 수 있으니 항상 주어진 상황과 해결하려는 방향에 맞게 적절하게 사용함을 기억해야 합니다.\nAbstract Factory 패턴과 함께 사용되는 패턴 Abstract Factory 패턴과 함께 사용하면 좋은 패턴으로는 Singleton 패턴이 있습니다. Singleton 패턴을 사용하여 팩토리 클래스의 인스턴스가 단일하게 유지되도록 함으로써, 일관된 객체 생성을 보장할 수 있습니다.\n이상으로 Abstract Factory 패턴에 대한 내용을 정리한 글입니다. 다른 패턴들과 함께 사용되거나 잘못 사용될 수 있는 경우 등에 대해서도 언급하였습니다. 이 글이 도움이 되기를 바랍니다.\n","permalink":"https://soulsy.github.io/samtech/ko/dev/design_pattern/abstract_faactory_pattern/","title":"디자인 패턴 02. Abstract Factory Pattern"},{"content":"Factory 패턴은 객체 생성을 캡슐화하여 유연성과 확장성을 제공하는 디자인 패턴입니다. 이 패턴은 클라이언트에게 직접 객체 생성을 맡기지 않고, 팩토리 메서드를 통해 객체를 생성하고 반환하는 방식을 사용합니다.\nFactory 패턴의 개요 Factory 패턴은 클라이언트가 객체를 생성하는 대신, 팩토리 메서드를 호출하여 객체를 생성하고 반환합니다. 이를 통해 클라이언트는 객체 생성과 관련된 복잡한 로직을 알 필요 없이, 팩토리 메서드를 통해 쉽게 객체를 생성할 수 있습니다.\n// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;야옹\u0026quot;); } } // 개 클래스 public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;멍멍\u0026quot;); } } // 새 클래스 public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;짹짹\u0026quot;); } } // Animal을 생성하는 AnimalFactory 클래스 public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;고양이\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;개\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;새\u0026quot;)) { return new Bird(); } return null; } } // 클라이언트 코드 public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;고양이\u0026quot;); cat.makeSound(); // 출력: \u0026quot;야옹\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;개\u0026quot;); dog.makeSound(); // 출력: \u0026quot;멍멍\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;새\u0026quot;); bird.makeSound(); // 출력: \u0026quot;짹짹\u0026quot; } } Factory 패턴의 장점 객체 생성 로직을 캡슐화하여 코드의 가독성과 유지보수성을 향상시킵니다. 새로운 객체를 추가하거나 기존 객체를 변경할 때, Factory 클래스의 팩토리 메서드만 수정하면 되므로 확장성이 좋습니다. 클라이언트는 객체 생성에 대한 결정을 팩토리 메서드에 위임함으로써 의존성을 낮출 수 있습니다. Factory 패턴을 잘못 사용하는 경우 Factory 패턴을 잘못 사용하면 코드가 복잡해질 수 있습니다. 과도한 팩토리 메서드의 사용이나 복잡한 조건문으로 인해 코드의 가독성과 유지보수성이 저하될 수 있습니다. 따라서, 적절한 상황과 용도에서 Factory 패턴을 사용해야 합니다.\n과도한 팩토리 메서드 사용으로 가독성과 유지보수성이 저하되는 예제 코드를 보여드리겠습니다:\n// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;야옹\u0026quot;); } } // 개 클래스 public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;멍멍\u0026quot;); } } // 새 클래스 public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;짹짹\u0026quot;); } } // Animal을 생성하는 AnimalFactory 클래스 public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;고양이\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;개\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;새\u0026quot;)) { return new Bird(); } else if (type.equalsIgnoreCase(\u0026quot;토끼\u0026quot;)) { return new Rabbit(); } else if (type.equalsIgnoreCase(\u0026quot;뱀\u0026quot;)) { return new Snake(); } return null; } } // 토끼 클래스 public class Rabbit implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;깡총깡총\u0026quot;); } } // 뱀 클래스 public class Snake implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;실실\u0026quot;); } } // 클라이언트 코드 public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;고양이\u0026quot;); cat.makeSound(); // 출력: \u0026quot;야옹\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;개\u0026quot;); dog.makeSound(); // 출력: \u0026quot;멍멍\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;새\u0026quot;); bird.makeSound(); // 출력: \u0026quot;짹짹\u0026quot; Animal rabbit = AnimalFactory.createAnimal(\u0026quot;토끼\u0026quot;); rabbit.makeSound(); // 출력: \u0026quot;깡총깡총\u0026quot; Animal snake = AnimalFactory.createAnimal(\u0026quot;뱀\u0026quot;); snake.makeSound(); // 출력: \u0026quot;실실\u0026quot; } } 위의 예제에서는 Factory 패턴을 사용하여 객체를 생성하고 있지만, 팩토리 메서드의 분기문이 많아져 가독성이 저하됩니다. 새로운 동물을 추가할 때마다 AnimalFactory 클래스의 팩토리 메서드를 수정해야 하는 번거로움이 있습니다. 이러한 상황에서는 팩토리 메서드의 사용을 줄이고, 추상 팩토리 패턴을 고려하는 것이 도움이 됩니다.\nFactory 패턴과 함께 사용되는 패턴 Factory 패턴과 함께 사용하면 좋은 패턴은 추상 팩토리(Abstract Factory) 패턴입니다. 추상 팩토리 패턴은 관련된 객체들을 생성하는 인터페이스를 제공하여 객체 생성에 대한 책임을 분리합니다.\nFactory 패턴과 함께 자주 등장하는 패턴으로는 Singleton 패턴이 있습니다. Singleton 패턴은 단일 인스턴스를 보장하고, 팩토리 클래스 내에서 단일 인스턴스를 생성할 수 있습니다.\n","permalink":"https://soulsy.github.io/samtech/ko/dev/design_pattern/faactory_pattern/","title":"디자인 패턴 01. Factory Pattern"},{"content":"삼테크에 오신 것을 환영합니다. 삼테크는 다양한 주제를 다루며 기술에 대한 토론을 진행하는 곳입니다. 삼테크라는 이름에 걸맞게 세 가지 주요 분야(News, Development, Knowledge)에 대해 다룹니다.\n삼테크는 보안 관련 주제도 다루지만, 주로 다양한 기술, 개발 및 IT 동향에 초점을 맞추고 있습니다. 우리는 기술 열정을 자유롭게 탐구하고 공유할 수 있는 플랫폼을 제공합니다. 함께 학습하고 정보를 교류하는 이 여정에 참여해보세요.\n","permalink":"https://soulsy.github.io/samtech/ko/about/","title":"About"}]