[{"content":"WordPress 플러그인 취약점을 이용한 비밀 관리자 계정 생성 공격 시도 출처: The Hacker News - 기사 링크\nThe Hacker News는 WordPress 플러그인인 Ultimate Member에서 발견된 심각한 보안 취약점을 이용한 지속적인 공격에 대해 보도하였습니다(CVE-2023-3460, CVSS score:9.8). 이 취약점으로 인해 최대 200,000개의 WordPress 웹사이트가 위험에 노출되었습니다.\n이 취약점은 Ultimate Member 플러그인의 모든 버전에 영향을 미치며, 최신 버전인 2.6.6(2023년 6월 29일에 출시됨)을 포함합니다.\nUltimate Member는 WordPress 사이트에서 사용자 프로필 및 커뮤니티 생성을 용이하게 하는 인기 있는 플러그인으로, 계정 관리 기능도 제공합니다.\nWordPress 보안 회사인 WPScan은 \u0026ldquo;이 문제는 매우 심각합니다. 인증되지 않은 공격자는 이 취약점을 이용하여 관리자 권한을 갖는 새로운 사용자 계정을 생성하여 해당 사이트를 완전히 제어할 수 있습니다\u0026quot;라고 경고하였습니다.\n해당 취약점에 대한 자세한 내용은 악용이 활발하게 진행되고 있어 공개되지 않았으나, 문제는 새로운 사용자의 wp_capabilities 메타 값을 관리자로 변경하여 사이트에 완전한 액세스 권한을 얻을 수 있는 불충분한 블록리스트 로직에서 기인한다고 합니다.\n\u0026ldquo;해당 플러그인에는 사용자가 업데이트할 수 없도록 설정된 사전 정의된 금지된 키 목록이 있지만, 취약한 버전의 플러그인에서는 다양한 대소문자, 슬래시 및 문자 인코딩을 활용하여 이러한 필터를 우회하는 간단한 방법이 있습니다\u0026quot;라고 Wordfence의 연구원인 Chloe Chamberland는 말하였습니다.\n이 문제는 해당 사이트에 악의적인 플러그인과 테마를 업로드하기 위해 새로운 계정을 등록하는 공격이 발생한 후에 알려졌으며, 플러그인 유지자들은 2.6.4, 2.6.5 및 2.6.6 버전에서 부분적인 수정 사항을 공\n개했습니다. 새로운 업데이트가 이후 몇 일 내에 출시될 예정입니다.\nWPScan은 패치가 불완전하며 여러 가지 우회 방법을 발견했다고 지적하며, 이 문제는 여전히 적극적으로 악용될 수 있다고 밝혔습니다.\n관찰된 공격에서는 해당 취약점을 이용하여 apadmins, se_brutal, segs_brutal, wpadmins, wpengine_backup 및 wpenginer와 같은 이름의 새로운 계정을 등록하고, 사이트의 관리 패널을 통해 악성 플러그인과 테마를 업로드하는 데 사용되고 있습니다.\nUltimate Member 사용자는 해당 보안 취약점이 완전히 막히는 적절한 패치가 제공될 때까지 플러그인을 비활성화하는 것이 좋습니다. 또한 웹사이트의 모든 관리자 수준의 사용자를 검토하여 무단으로 추가된 계정이 있는지 확인하는 것이 권장됩니다.\nUltimate Member 2.6.7 버전 출시 Ultimate Member 제작자는 2023년 7월 1일에 플러그인의 취약점을 적극적으로 악용하는 것을 해결하기 위해 2.6.7 버전을 출시하였습니다. 추가적인 보안 조치로서, 웹사이트 관리자가 모든 사용자의 비밀번호를 재설정할 수 있도록 플러그인 내에 새로운 기능을 제공할 예정입니다.\n\u0026ldquo;2.6.7 버전은 양식을 전송하는 동안 저장하는 메타 키에 대한 화이트리스트 기능을 도입합니다\u0026quot;라고 유지자들은 독립적인 고지에서 밝혔습니다. \u0026ldquo;또한 2.6.7 버전은 양식 설정 데이터와 제출된 데이터를 분리하여 2개의 다른 변수에서 처리합니다.\u0026rdquo;\n참고: 위 내용은 The Hacker News에서 발행된 기사의 요약입니다. 전문 기사를 읽고 더 많은 정보를 얻으려면 원본 출처를 방문하십시오.\n","permalink":"https://soulsy.github.io/samtech/ko/news/003/","title":"WordPress 플러그인 취약점을 이용한 비밀 관리자 계정 생성 공격 시도"},{"content":"포르노 연령 확인 수단의 개인정보 침해 가능성 in UK 출처: BBC News - 기사 링크\n영국 정부는 온라인 상에서 어린이를 보호하기 위한 새로운 인터넷 안전 법을 도입하고 있습니다. 그러나 이에 대한 개인정보 보호에 대한 우려가 제기되고 있습니다. 제안된 온라인 안전 법에 따르면 포르노그래피 콘텐츠를 게시하거나 허용하는 플랫폼은 연령 확인 조치를 시행해야 합니다. 그러나 디지털 권리 단체들은 이러한 도구의 투명성과 데이터 수집 방법에 대해 의문을 제기하고 있습니다.\n이러한 개정안에 따르면, 소셜 미디어와 같은 사용자 간 플랫폼은 사용자가 어린이인지 여부를 \u0026ldquo;매우 효과적으로\u0026rdquo; 확인할 수 있는 연령 확인 기술을 사용해야 합니다. 이는 셀카로부터 나이를 추정하는 방법이나 공식 신분증이나 은행 내역 확인 등의 방법을 포함할 수 있습니다. 정부는 이 법안이 유연하다고 주장하고 있지만, 비판자들은 사람들의 개인정보 보호가 충분히 보장되지 않을 수 있다고 주장하고 있습니다.\n오픈 라이츠 그룹의 정책 매니저인 못리카 호튼 박사는 연령 확인 기술의 도입에 대한 우려를 표명했습니다. 특히, 어린이의 생체 인식 데이터를 민간 기업이 적절한 거버넌스 구조 없이 대규모로 수집하는 것에 따른 잠재적인 위험에 대해 더 많은 고려가 필요하다고 말했습니다. 이러한 데이터의 보관, 접근 및 처리 방법은 여전히 명확하지 않습니다.\n이 법안은 통신 규제 기관인 Ofcom에게 기술 기업에 대한 과징금 부과, 웹 사이트 접근 제한, 협력하지 않는 기업의 임원들에게 형사 책임을 부여하는 권한을 부여합니다. 그러나 많은 성인 웹 사이트가 존재하는 상황에서 이러한 규\n정을 보다 효과적으로 시행하기 위해 개선된 권한이 요구되고 있습니다.\n비판자들은 공식 문서 제출이 힘든 경제 계층에서 차별이 발생할 수 있다는 우려도 제기하고 있습니다. 기술 장관인 폴 스컬리는 성교육 콘텐츠가 차단될 수 있는 우려에 대해 걱정하지 않아도 된다고 밝혔습니다. 미성년자를 위한 콘텐츠의 이용 가능 여부는 Ofcom이 결정할 것이라고 말했습니다.\n온라인 안전 법은 유해 콘텐츠로부터 소셜 미디어 사용자, 특히 어린이를 보호하면서도 표현의 자유를 보존하려는 목표를 가지고 있습니다. 이 법안은 플랫폼의 안전을 확보하기 위해 최고 경영자들을 책임지게 하여, 규정에 불응하는 기술 임원에게 징역 형을 부과할 수도 있습니다.\n이 법안은 아직 변경될 여지가 있으며, 다음 주에 상원에서 투표 예정입니다. 애플 등 기업들은 아동 학대 자료를 검색하기 위해 메시징 서비스가 최종 사용자 간 암호화를 해제해야 하는 규정에 대한 우려를 표명했습니다.\n본 블로그 포스팅은 BBC News의 기사를 요약한 내용입니다. 자세한 내용 및 전문 기사는 원문 링크를 참고해 주세요.\n","permalink":"https://soulsy.github.io/samtech/ko/news/002/","title":"포르노 연령 확인 수단의 개인정보 침해 가능성 in UK"},{"content":"OpenAI, 런던에 국제 사무소 설립 계획 발표 출처: BBC News - 기사 링크\nChatGPT를 개발한 미국 기업인 OpenAI가 국제 사무소를 처음으로 런던에 설립할 계획을 발표했습니다. 이는 세계적인 인재를 유치하는 \u0026ldquo;기회\u0026quot;라고 OpenAI의 최고 경영자인 Sam Altman이 말했습니다.\n이러한 결정은 OpenAI 최고 경영자인 Sam Altman이 인공지능(AI) 관련 규제를 제안한 유럽연합(EU)에 비판적인 입장을 표명한 후에 이루어졌습니다. EU의 제안은 기업들이 AI 시스템 교육에 사용된 콘텐츠를 공개해야 한다는 내용을 담고 있습니다. 반면, 영국은 \u0026ldquo;혁신 촉진\u0026rdquo; 정책을 계획 중에 있습니다.\nOpenAI 인사 부사장인 Diane Yoon은 \u0026ldquo;우리는 런던에 연구 및 개발 팀을 구축하기 위해 열정적입니다. 이 도시는 풍부한 문화와 우수한 인재 풀로 유명합니다. 안전한 AI를 창조하고 홍보하기 위한 노력을 강화하기 위해 역동적인 팀을 구성하고자 합니다\u0026quot;라고 말했습니다.\nChatGPT는 지난 11월에 등장하여 인간과 유사한 답변을 제공하는 능력으로 글로벌한 관심을 불러일으켰습니다. 이는 AI 기반 제품에 대한 위협과 그에 필요한 규제에 대한 논쟁을 일으켰습니다.\n지난 5월에 열린 로스톤 대학교의 행사에서 Sam Altman은 AI가 일자리를 창출하고 불평등을 줄일 수 있다고 믿는다고 말했습니다. 이에 대해 Rishi Sunak 영국 총리는 AI가 \u0026ldquo;인류를 긍정적으로 변화시킬 수 있으며, 공공 서비스 개선을 통해 영국 국민에게 더 나은 결과를 제공할 수 있다\u0026quot;고 말했습니다.\nChatGPT는 논란을 빚어 2023년 4월에 복원되기 전 잠시 동안 이탈리아에서 금지되기도 했습니다. 영국 정부는 2014년 이후로 25억 파운드를 AI에 투자했다고 밝혔습니다.\n영국의 과학, 혁신 및 기술 비서인 Chloe Smith는 OpenAI의 결정이 영국을 AI 강국으로 인정하는 의미로 \u0026ldquo;우리의 활기찬 기술 생태계와 탁월한 인재에 대한 신뢰 표시\u0026quot;라고 말했습니다. 영국은 현재 AI 분야에서 전국적으로 5만 명 이상의 직원을 고용하고 있으며, 인공지능에 대한 세계적 목적지로 자리매김하기 위해 노력할 것입니다.\n참고: 위 블로그 포스팅은 BBC News의 기사 요약입니다. 자세한 내용과 전문은 원문 기사를 참조해 주세요.\n","permalink":"https://soulsy.github.io/samtech/ko/news/001/","title":"OpenAI, 런던에 국제 사무소 설립 계획 발표"},{"content":"Prototype 패턴 개요 Prototype 패턴은 객체 생성 비용을 줄이고, 새로운 객체를 생성하기 위해 기존 객체를 복제하는 디자인 패턴입니다. Prototype 패턴은 다음과 요소를 가지고 있습니다:\nPrototype 인터페이스 또는 추상 클래스: 복제 기능을 선언하는 메서드를 정의합니다. ConcretePrototype 클래스: Prototype 인터페이스를 구체적으로 구현하고, 객체의 복제를 수행하는 메서드를 제공합니다. Client: 복제를 요청하고, 새로운 객체를 생성하는 역할을 합니다. // Prototype 인터페이스 public interface Prototype { Prototype clone(); } // ConcretePrototype 클래스 public class ConcretePrototype implements Prototype { private String property; public ConcretePrototype(String property) { this.property = property; } public Prototype clone() { return new ConcretePrototype(this.property); } public void setProperty(String property) { this.property = property; } public String getProperty() { return property; } } // Client 클래스 public class Client { public static void main(String[] args) { // 기존 객체 생성 ConcretePrototype prototype = new ConcretePrototype(\u0026quot;Original\u0026quot;); // 객체 복제 ConcretePrototype clonedObject = (ConcretePrototype) prototype.clone(); // 복제된 객체의 속성 변경 clonedObject.setProperty(\u0026quot;Cloned\u0026quot;); System.out.println(\u0026quot;Original Object: \u0026quot; + prototype.getProperty()); System.out.println(\u0026quot;Cloned Object: \u0026quot; + clonedObject.getProperty()); } } 위의 예제 코드에서는 Prototype 인터페이스를 정의하고, ConcretePrototype 클래스가 이를 구현합니다. ConcretePrototype 클래스는 clone() 메서드를 구현하여 자신을 복제할 수 있습니다. Client 클래스에서는 기존 객체를 생성하고 복제한 객체를 생성한 뒤, 복제된 객체의 속성을 변경하여 결과를 출력합니다.\nPrototype 패턴 장점 객체의 복제를 통해 객체 생성 비용을 줄일 수 있습니다. 기존 객체를 복제하여 필요한 부분만 변경하여 새로운 객체를 생성할 수 있습니다. 객체 생성 과정을 단순화할 수 있습니다. 복잡한 초기화 과정을 거치지 않고, 기존 객체의 상태를 복제하여 새로운 객체를 생성할 수 있습니다. Prototype 패턴 사용 시 주의할 점 객체의 복제 과정에서 얕은 복사와 깊은 복사를 구분해야 합니다. 얕은 복사는 참조된 객체의 주소만 복사하므로 원본과 복사본이 동일한 객체를 참조할 수 있습니다. 깊은 복사는 참조된 객체를 새로 생성하여 복사하므로 원본과 복사본이 독립적인 객체를 참조합니다. 객체가 복잡한 상태를 가지고 있을 때, 모든 상태를 정확하게 복제해야 합니다. 복제를 수행하는 메서드를 구현할 때 신경써야 합니다. Prototype 패턴은 객체의 구조적인 변경을 동적으로 처리하기 어렵습니다. 객체의 구조가 변경되었을 때, 모든 복제 관련 코드를 수정해야 할 수도 있습니다. 아래는 객체의 복제를 잘못 구현하여 Prototype 패턴을 적절히 사용하지 못한 예제 코드입니다:\n// Prototype 인터페이스 public interface Prototype { Prototype clone(); } // ConcretePrototype 클래스 public class ConcretePrototype implements Prototype { private int[] array; public ConcretePrototype(int[] array) { this.array = array; } public Prototype clone() { return new ConcretePrototype(this.array); // 잘못된 복제 방식 } public void setArrayValue(int index, int value) { array[index] = value; } public int[] getArray() { return array; } } // Client 클래스 public class Client { public static void main(String[] args) { // 기존 객체 생성 int[] originalArray = {1, 2, 3}; ConcretePrototype prototype = new ConcretePrototype(originalArray); // 객체 복제 ConcretePrototype clonedObject = (ConcretePrototype) prototype.clone(); // 복제된 객체의 배열 값 변경 clonedObject.setArrayValue(0, 99); System.out.println(\u0026quot;Original Array: \u0026quot; + Arrays.toString(prototype.getArray())); System.out.println(\u0026quot;Cloned Array: \u0026quot; + Arrays.toString(clonedObject.getArray())); } } 위의 예제 코드에서는 ConcretePrototype 클래스의 clone() 메서드를 구현할 때, 배열을 얕은 복사하여 복제하고 있습니다. 이 경우, 원본 객체와 복제 객체가 같은 배열 객체를 참조하게 됩니다. 따라서 setArrayValue() 메서드를 통해 복제된 객체의 배열 값을 변경하면 원본 객체의 배열 값도 변경되는 문제가 발생합니다.\n이러한 경우, 올바른 복제 방식은 깊은 복사를 수행하여 복제된 객체와 원본 객체가 서로 독립적인 배열 객체를 참조하도록 해야 합니다. 예를 들어, 배열을 새로 생성하고 배열 요소를 복사하는 방식으로 복제를 수행해야 합니다.\nPrototype 패턴과 함께 사용되는 패턴 추상 팩토리(Abstract Factory) 패턴: 추상 팩토리 패턴을 사용하여 Prototype 인스턴스를 관리하고, 이를 기반으로 새로운 객체를 생성할 수 있습니다. 빌더(Builder) 패턴: 빌더 패턴을 사용하여 Prototype객체를 복제하고, 추가적인 구성 작업을 수행할 수 있습니다. 단일체(Singleton) 패턴: 단일체 패턴을 사용하여 Prototype 인스턴스를 공유하고, 필요에 따라 복제하여 새로운 객체를 생성할 수 있습니다. ","permalink":"https://soulsy.github.io/samtech/ko/dev/design_pattern/prototype_pattern/","title":"디자인 패턴 05. Prototype Pattern"},{"content":"Builder 패턴의 개요 Builder 패턴은 객체 생성을 유연하고 직관적으로 만들기 위한 디자인 패턴입니다. 이 패턴은 복잡한 객체의 생성 과정을 추상화하고, 사용자가 단계별로 객체를 구성할 수 있게 합니다.\nBuilder 패턴은 다음과 같은 요소로 구성됩니다:\nDirector: 객체 생성을 담당하며, Builder 인터페이스를 사용하여 객체를 구성합니다. Builder: 객체 생성을 위한 인터페이스를 정의하고, 객체의 각 부분을 구성하는 메서드를 제공합니다. ConcreteBuilder: Builder 인터페이스를 구현하여 객체를 구성하는 역할을 합니다. Product: 생성할 객체의 표현입니다. // Product 클래스 public class Product { private String partA; private String partB; private String partC; public void setPartA(String partA) { this.partA = partA; } public void setPartB(String partB) { this.partB = partB; } public void setPartC(String partC) { this.partC = partC; } public String getResult() { return \u0026quot;Part A: \u0026quot; + partA + \u0026quot;, Part B: \u0026quot; + partB + \u0026quot;, Part C: \u0026quot; + partC; } } // Builder 인터페이스 public interface Builder { void buildPartA(); void buildPartB(); void buildPartC(); Product getResult(); } // ConcreteBuilder 클래스 public class ConcreteBuilder implements Builder { private Product product; public ConcreteBuilder() { this.product = new Product(); } public void buildPartA() { product.setPartA(\u0026quot;A\u0026quot;); } public void buildPartB() { product.setPartB(\u0026quot;B\u0026quot;); } public void buildPartC() { product.setPartC(\u0026quot;C\u0026quot;); } public Product getResult() { return product; } } // Director 클래스 public class Director { private Builder builder; public void setBuilder(Builder builder) { this.builder = builder; } public Product construct() { builder.buildPartA(); builder.buildPartB(); builder.buildPartC(); return builder.getResult(); } } // 예제 코드 사용 public class Main { public static void main(String[] args) { Director director = new Director(); Builder builder = new ConcreteBuilder(); director.setBuilder(builder); Product product = director.construct(); System.out.println(product.getResult()); } } 위의 예제 코드에서 Builder 패턴을 사용하여 Product 객체를 생성하고 구성합니다. Builder 인터페이스는 객체 생성을 위한 메서드를 정의하고, ConcreteBuilder 클래스는 해당 인터페이스를 구현하여 실제 객체를 생성하고 구성합니다. Director 클래스는 Builder 인터페이스를 사용하여 객체 생성 과정을 조정하고, 최종적으로 Product 객체를 반환합니다.\n이 예제 코드는 Builder 패턴의 기본적인 구현을 보여줍니다. 각 부분을 적절히 확장하고, 객체의 유효성 검사를 추가하여 실제 프로덕션 환경에서 사용할 수 있는 완전한 Builder 패턴을 구현할 수 있습니다.\nBuilder 패턴의 장점 Builder 패턴은 다음과 같은 장점을 가집니다:\n객체의 생성 과정을 단계적으로 수행하므로, 객체의 구성이 명확하고 유연합니다. 복잡한 객체를 생성할 때, 가독성이 높은 코드를 작성할 수 있습니다. 객체 생성 과정에 대한 의존성을 외부로 노출시키지 않으므로, 객체의 일관성과 안정성을 보장합니다. Builder 패턴을 쓸 때 주의해야 할 점 Builder 패턴을 사용할 때 주의해야 할 점은 다음과 같습니다:\n객체의 생성 과정을 단계적으로 수행하기 때문에, 객체의 일부 구성 요소가 유효하지 않은 상태로 사용될 수 있습니다. 이를 방지하기 위해 객체의 유효성 검사를 수행해야 합니다. Builder 패턴은 일반적으로 복잡한 객체 생성에 사용되지만, 단순한 객체에는 비효율적일 수 있습니다. 객체의 구성 단계가 많거나 복잡하지 않은 경우에는 다른 생성 패턴을 고려해야 합니다. 다음은 단순한 객체의 생성에 Builder 패턴을 사용하여 비효율적인 예제 코드입니다:\npublic class SimpleObject { private String propertyA; private String propertyB; private String propertyC; public SimpleObject(String propertyA, String propertyB, String propertyC) { this.propertyA = propertyA; this.propertyB = propertyB; this.propertyC = propertyC; } // Getters and setters } public class SimpleObjectBuilder { private String propertyA; private String propertyB; private String propertyC; public SimpleObjectBuilder() { } public SimpleObjectBuilder setPropertyA(String propertyA) { this.propertyA = propertyA; return this; } public SimpleObjectBuilder setPropertyB(String propertyB) { this.propertyB = propertyB; return this; } public SimpleObjectBuilder setPropertyC(String propertyC) { this.propertyC = propertyC; return this; } public SimpleObject build() { return new SimpleObject(propertyA, propertyB, propertyC); } } public class Main { public static void main(String[] args) { SimpleObjectBuilder builder = new SimpleObjectBuilder(); SimpleObject simpleObject = builder.setPropertyA(\u0026quot;A\u0026quot;) .setPropertyB(\u0026quot;B\u0026quot;) .setPropertyC(\u0026quot;C\u0026quot;) .build(); } } 위의 예제 코드에서는 단순한 객체인 SimpleObject를 생성하는 데 Builder 패턴을 사용하였습니다. 그러나 SimpleObject 클래스의 생성자에 이미 필요한 속성들을 받아 초기화할 수 있는 방법이 제공되므로, Builder 패턴을 사용하는 것은 비효율적입니다. 객체의 생성에 불필요한 중간 단계인 SimpleObjectBuilder를 거치므로 코드가 더 복잡해지고 가독성이 떨어집니다.\n효율적인 방법은 다음과 같이 바로 SimpleObject 객체를 생성하는 것입니다:\npublic class Main { public static void main(String[] args) { SimpleObject simpleObject = new SimpleObject(\u0026quot;A\u0026quot;, \u0026quot;B\u0026quot;, \u0026quot;C\u0026quot;); } } 이렇게 하면 불필요한 Builder 클래스를 사용하지 않고도 단순한 객체를 직접 생성할 수 있습니다.\nBuilder 패턴과 함께 사용되는 다른 패턴 Builder 패턴은 다른 디자인 패턴과 함께 사용될 수 있습니다. 자주 함께 사용되는 패턴들은 다음과 같습니다:\n추상 팩토리(Abstract Factory) 패턴: 추상 팩토리 패턴을 사용하여 여러 종류의 Builder 인터페이스를 생성하고, 각 Builder 인터페이스에 대응하는 ConcreteBuilder를 사용하여 다양한 종류의 객체를 생성할 수 있습니다. 프로토 타입(Prototype) 패턴: 프로토 타입 패턴을 사용하여 기존의 객체를 복제하고, Builder 패턴을 사용하여 복제된 객체를 수정하거나 추가 구성할 수 있습니다. 일관된 인터페이스(Uniform Interface) 패턴: Builder 패턴을 사용하여 여러 객체를 생성할 때, 일관된 인터페이스를 사용하여 객체를 생성하고 구성할 수 있습니다. ","permalink":"https://soulsy.github.io/samtech/ko/dev/design_pattern/builder_pattern/","title":"디자인 패턴 04. Builder Pattern"},{"content":"Singleton 패턴은 클래스의 인스턴스가 단일하게 유지되도록 보장하는 디자인 패턴입니다. 이 패턴은 어떤 클래스의 인스턴스가 하나만 존재하고, 이를 전역적으로 접근할 수 있는 방법을 제공합니다.\nSingleton 패턴의 개요 Singleton 패턴은 다음과 같은 특징을 가집니다:\n클래스의 인스턴스가 오직 하나만 존재합니다. 전역적으로 접근 가능한 접근점을 제공하여 어디서든 동일한 인스턴스에 접근할 수 있습니다. Singleton 패턴은 다양한 상황에서 유용하게 사용될 수 있으며, 자주 사용되는 패턴 중 하나입니다.\nSingleton 패턴의 장점 Singleton 패턴은 다음과 같은 장점을 가집니다:\n하나의 인스턴스만 존재하므로, 자원의 낭비를 줄일 수 있습니다. 전역적인 접근점을 통해 인스턴스에 접근할 수 있으므로, 간편한 사용이 가능합니다. Singleton 패턴을 잘못 사용하는 경우 Singleton 패턴을 잘못 사용하면 다음과 같은 문제가 발생할 수 있습니다:\n멀티스레드 환경에서 동기화 문제가 발생할 수 있습니다. 동시에 여러 스레드가 인스턴스 생성을 요청할 경우, 여러 인스턴스가 생성될 수 있습니다. 테스트 용이성이 저하될 수 있습니다. Singleton 인스턴스가 의존성으로 주입되지 않고 전역적으로 사용되기 때문에 테스트하기 어려울 수 있습니다. 단일 책임 원칙(Single Responsibility Principle)에 위배될 수 있습니다. Singleton 클래스가 다른 기능을 포함하면서 인스턴스 유일성을 유지하기 위한 코드가 추가될 경우, 클래스의 책임이 너무 많아질 수 있습니다. 잘못된 Singleton 패턴은 다음과 같은 문제를 일으킬 수 있습니다. 여러 스레드가 동시에 인스턴스를 생성할 수 있어서 여러 인스턴스가 생성되거나, 인스턴스의 일관성을 보장할 수 없는 경우입니다. 아래는 이러한 문제가 발생하는 잘못된 Singleton 패턴의 예시 코드입니다.\npublic class BadSingleton { private static BadSingleton instance; private BadSingleton() { // 인스턴스 생성 로직 } public static BadSingleton getInstance() { if (instance == null) { // 여러 스레드가 동시에 이 부분에 진입할 수 있음 instance = new BadSingleton(); } return instance; } // 기타 기능 및 데이터 멤버 } 위의 코드에서 getInstance() 메서드는 여러 스레드가 동시에 인스턴스를 생성할 수 있는 문제가 있습니다. 여러 스레드가 동시에 instance가 null인 것을 확인하고 인스턴스를 생성하게 되면, 서로 다른 인스턴스가 생성될 수 있습니다.\n이러한 상황에서는 동기화(synchronization) 문제를 해결해야 합니다. 아래는 동기화를 추가하여 올바르게 동작하는 Singleton 패턴의 예시 코드입니다.\npublic class GoodSingleton { private static GoodSingleton instance; private GoodSingleton() { // 인스턴스 생성 로직 } public static synchronized GoodSingleton getInstance() { if (instance == null) { instance = new GoodSingleton(); } return instance; } // 기타 기능 및 데이터 멤버 } 위의 코드에서 getInstance() 메서드에 synchronized 키워드를 추가하여 동기화하였습니다. 이를 통해 여러 스레드가 동시에 getInstance() 메서드에 접근하는 것을 방지하고, 하나의 스레드만이 인스턴스를 생성할 수 있도록 보장합니다.\n올바르게 동작하는 Singleton 패턴은 멀티스레드 환경에서 안전하게 사용할 수 있습니다. 하지만 Singleton 패턴을 사용할 때는 주의해야 하며, 필요한 경우에만 사용하는 것이 좋습니다.\nSingleton 패턴과 함께 사용하면 좋은 패턴 Singleton 패턴과 함께 사용하면 좋은 패턴으로는 Abstract Factory 패턴이 있습니다. Abstract Factory 패턴을 사용하여 Singleton 패턴으로 생성된 인스턴스를 활용할 수 있습니다. Singleton 패턴을 적용하여 팩토리 클래스의 인스턴스가 단일하게 유지되면, 일관된 객체 생성을 보장할 수 있습니다.\n아래는 Singleton 패턴과 Abstract Factory 패턴을 함께 사용하는 예제 코드입니다.\n// Singleton 패턴을 적용한 팩토 리 클래스 public class SingletonFactory implements AbstractFactory { private static SingletonFactory instance; private SingletonFactory() { // 인스턴스 생성 로직 } public static synchronized SingletonFactory getInstance() { if (instance == null) { instance = new SingletonFactory(); } return instance; } public AbstractProductA createProductA() { return new ConcreteProductA(); } public AbstractProductB createProductB() { return new ConcreteProductB(); } } // Abstract Factory 패턴을 위한 인터페이스 public interface AbstractFactory { AbstractProductA createProductA(); AbstractProductB createProductB(); } // 구체적인 제품 클래스 public class ConcreteProductA implements AbstractProductA { // 제품 A의 구현 } public class ConcreteProductB implements AbstractProductB { // 제품 B의 구현 } 위의 예제 코드에서 Singleton 패턴을 적용한 SingletonFactory 클래스는 AbstractFactory 인터페이스를 구현합니다. SingletonFactory 클래스의 인스턴스는 Singleton 패턴에 따라 단일하게 유지되며, createProductA 및 createProductB 메서드를 통해 객체를 생성합니다.\n이렇게 함께 사용되는 경우, Singleton 패턴을 통해 Abstract Factory 패턴의 구체 팩토리 클래스의 인스턴스가 단일하게 유지되므로, 일관된 객체 생성이 가능해집니다.\n","permalink":"https://soulsy.github.io/samtech/ko/dev/design_pattern/singleton_pattern/","title":"디자인 패턴 03. Singleton Pattern"},{"content":"Abstract Factory 패턴은 관련된 객체들을 생성하는 인터페이스를 제공하여 객체 생성에 대한 책임을 분리하는 디자인 패턴입니다. 이 패턴은 서로 연관된 다수의 객체를 생성해야 할 때 유용하며, 구체적인 클래스에 의존하지 않고 객체를 생성할 수 있도록 합니다.\nAbstract Factory 패턴의 개요 Abstract Factory 패턴은 클라이언트가 객체를 생성하는 대신, 추상 팩토리 인터페이스를 통해 관련 객체들을 생성합니다. 추상 팩토리는 관련된 객체들의 집합에 대한 인터페이스를 제공하며, 구체적인 팩토리 클래스는 이 인터페이스를 구현하여 실제 객체를 생성합니다. 이를 통해 클라이언트는 구체적인 클래스에 직접 의존하지 않고도 객체를 생성할 수 있습니다.\n예제 코드 // 추상 제품 A public interface AbstractProductA { void performAction(); } // 추상 제품 B public interface AbstractProductB { void performAction(); } // 구체적인 제품 A1 public class ConcreteProductA1 implements AbstractProductA { @Override public void performAction() { System.out.println(\u0026quot;ConcreteProductA1에서 동작 수행\u0026quot;); } } // 구체적인 제품 A2 public class ConcreteProductA2 implements AbstractProductA { @Override public void performAction() { System.out.println(\u0026quot;ConcreteProductA2에서 동작 수행\u0026quot;); } } // 구체적인 제품 B1 public class ConcreteProductB1 implements AbstractProductB { @Override public void performAction() { System.out.println(\u0026quot;ConcreteProductB1에서 동작 수행\u0026quot;); } } // 구체적인 제품 B2 public class ConcreteProductB2 implements AbstractProductB { @Override public void performAction() { System.out.println(\u0026quot;ConcreteProductB2에서 동작 수행\u0026quot;); } } // 추상 팩토리 인터페이스 public interface AbstractFactory { AbstractProductA createProductA(); AbstractProductB createProductB(); } // 구체적인 팩토리 A public class ConcreteFactoryA implements AbstractFactory { @Override public AbstractProductA createProductA() { return new ConcreteProductA1(); } @Override public AbstractProductB createProductB() { return new ConcreteProductB1(); } } // 구체적인 팩토리 B public class ConcreteFactoryB implements AbstractFactory { @Override public AbstractProductA createProductA() { return new ConcreteProductA2(); } @Override public AbstractProductB createProductB() { return new ConcreteProductB2(); } } // 클라이언트 코드 public class Client { private AbstractProductA productA; private AbstractProductB productB; public Client(AbstractFactory factory) { productA = factory.createProductA(); productB = factory.createProductB(); } public void performActions() { productA.performAction(); productB.performAction(); } public static void main(String[] args) { AbstractFactory factoryA = new ConcreteFactoryA(); Client clientA = new Client(factoryA); clientA.performActions(); // 출력: // ConcreteProductA1에서 동작 수행 // ConcreteProductB1에서 동작 수행 AbstractFactory factoryB = new ConcreteFactoryB(); Client clientB = new Client(factoryB); clientB.performActions(); // 출력: // ConcreteProductA2에서 동작 수행 // ConcreteProductB2에서 동작 수행 } } Abstract Factory 패턴의 장점 관련된 객체들을 생성하기 위한 일관된 인터페이스를 제공하여 객체 생성에 대한 책임을 분리합니다. 클라이언트는 구체적인 클래스에 직접 의존하지 않고도 객체를 생성할 수 있습니다. 객체들의 일관성과 호환성을 유지할 수 있습니다. 새로운 구체 팩토리 클래스를 추가하여 다양한 객체 구성을 생성할 수 있습니다. Factory 패턴과 Abstract Factory 패턴 비교 앞서 Factory 패턴의 글에서 말했던 것처럼 과도한 Factory 패턴의 사용이 불필요한 분기문으로 가독성이 떨어지는 상황이 발생할 수 있습니다. 아래 예제는 Factory 패턴의 과한 사용으로 코드 가독성이 떨어지는 예제입니다.\n// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;야옹\u0026quot;); } } // 개 클래스 public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;멍멍\u0026quot;); } } // 새 클래스 public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;짹짹\u0026quot;); } } // Animal을 생성하는 AnimalFactory 클래스 public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;고양이\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;개\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;새\u0026quot;)) { return new Bird(); } else if (type.equalsIgnoreCase(\u0026quot;토끼\u0026quot;)) { return new Rabbit(); } else if (type.equalsIgnoreCase(\u0026quot;뱀\u0026quot;)) { return new Snake(); } return null; } } // 토끼 클래스 public class Rabbit implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;깡총깡총\u0026quot;); } } // 뱀 클래스 public class Snake implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;실실\u0026quot;); } } // 클라이언트 코드 public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;고양이\u0026quot;); cat.makeSound(); // 출력: \u0026quot;야옹\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;개\u0026quot;); dog.makeSound(); // 출력: \u0026quot;멍멍\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;새\u0026quot;); bird.makeSound(); // 출력: \u0026quot;짹짹\u0026quot; Animal rabbit = AnimalFactory.createAnimal(\u0026quot;토끼\u0026quot;); rabbit.makeSound(); // 출력: \u0026quot;깡총깡총\u0026quot; Animal snake = AnimalFactory.createAnimal(\u0026quot;뱀\u0026quot;); snake.makeSound(); // 출력: \u0026quot;실실\u0026quot; } } Abstract Factory 패턴을 사용하면 아래와 같이 리팩토링을 진행해 볼 수 있습니다.\n// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;야옹\u0026quot;); } } // 개 클래스 public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;멍멍\u0026quot;); } } // 새 클래스 public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;짹짹\u0026quot;); } } // 추상 동물 팩토리 public interface AnimalFactory { Animal createAnimal(); } // 고양이 팩토리 public class CatFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Cat(); } } // 개 팩토리 public class DogFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Dog(); } } // 새 팩토리 public class BirdFactory implements AnimalFactory { @Override public Animal createAnimal() { return new Bird(); } } // 클라이언트 코드 public class Client { public static void main(String[] args) { AnimalFactory catFactory = new CatFactory(); Animal cat = catFactory.createAnimal(); cat.makeSound(); // 출력: \u0026quot;야옹\u0026quot; AnimalFactory dogFactory = new DogFactory(); Animal dog = dogFactory.createAnimal(); dog.makeSound(); // 출력: \u0026quot;멍멍\u0026quot; AnimalFactory birdFactory = new BirdFactory(); Animal bird = birdFactory.createAnimal(); bird.makeSound(); // 출력: \u0026quot;짹짹\u0026quot; } } 물론 Abstract Factory 패턴도 과도하게 사용하면 Factory 패턴과 마찬가지로 부작용이 생길 수 있으니 항상 주어진 상황과 해결하려는 방향에 맞게 적절하게 사용함을 기억해야 합니다.\nAbstract Factory 패턴과 함께 사용되는 패턴 Abstract Factory 패턴과 함께 사용하면 좋은 패턴으로는 Singleton 패턴이 있습니다. Singleton 패턴을 사용하여 팩토리 클래스의 인스턴스가 단일하게 유지되도록 함으로써, 일관된 객체 생성을 보장할 수 있습니다.\n이상으로 Abstract Factory 패턴에 대한 내용을 정리한 글입니다. 다른 패턴들과 함께 사용되거나 잘못 사용될 수 있는 경우 등에 대해서도 언급하였습니다. 이 글이 도움이 되기를 바랍니다.\n","permalink":"https://soulsy.github.io/samtech/ko/dev/design_pattern/abstract_factory_pattern/","title":"디자인 패턴 02. Abstract Factory Pattern"},{"content":"Factory 패턴은 객체 생성을 캡슐화하여 유연성과 확장성을 제공하는 디자인 패턴입니다. 이 패턴은 클라이언트에게 직접 객체 생성을 맡기지 않고, 팩토리 메서드를 통해 객체를 생성하고 반환하는 방식을 사용합니다.\nFactory 패턴의 개요 Factory 패턴은 클라이언트가 객체를 생성하는 대신, 팩토리 메서드를 호출하여 객체를 생성하고 반환합니다. 이를 통해 클라이언트는 객체 생성과 관련된 복잡한 로직을 알 필요 없이, 팩토리 메서드를 통해 쉽게 객체를 생성할 수 있습니다.\n// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;야옹\u0026quot;); } } // 개 클래스 public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;멍멍\u0026quot;); } } // 새 클래스 public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;짹짹\u0026quot;); } } // Animal을 생성하는 AnimalFactory 클래스 public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;고양이\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;개\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;새\u0026quot;)) { return new Bird(); } return null; } } // 클라이언트 코드 public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;고양이\u0026quot;); cat.makeSound(); // 출력: \u0026quot;야옹\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;개\u0026quot;); dog.makeSound(); // 출력: \u0026quot;멍멍\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;새\u0026quot;); bird.makeSound(); // 출력: \u0026quot;짹짹\u0026quot; } } Factory 패턴의 장점 객체 생성 로직을 캡슐화하여 코드의 가독성과 유지보수성을 향상시킵니다. 새로운 객체를 추가하거나 기존 객체를 변경할 때, Factory 클래스의 팩토리 메서드만 수정하면 되므로 확장성이 좋습니다. 클라이언트는 객체 생성에 대한 결정을 팩토리 메서드에 위임함으로써 의존성을 낮출 수 있습니다. Factory 패턴을 잘못 사용하는 경우 Factory 패턴을 잘못 사용하면 코드가 복잡해질 수 있습니다. 과도한 팩토리 메서드의 사용이나 복잡한 조건문으로 인해 코드의 가독성과 유지보수성이 저하될 수 있습니다. 따라서, 적절한 상황과 용도에서 Factory 패턴을 사용해야 합니다.\n과도한 팩토리 메서드 사용으로 가독성과 유지보수성이 저하되는 예제 코드를 보여드리겠습니다:\n// 동물 인터페이스 public interface Animal { void makeSound(); } // 고양이 클래스 public class Cat implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;야옹\u0026quot;); } } // 개 클래스 public class Dog implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;멍멍\u0026quot;); } } // 새 클래스 public class Bird implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;짹짹\u0026quot;); } } // Animal을 생성하는 AnimalFactory 클래스 public class AnimalFactory { public static Animal createAnimal(String type) { if (type.equalsIgnoreCase(\u0026quot;고양이\u0026quot;)) { return new Cat(); } else if (type.equalsIgnoreCase(\u0026quot;개\u0026quot;)) { return new Dog(); } else if (type.equalsIgnoreCase(\u0026quot;새\u0026quot;)) { return new Bird(); } else if (type.equalsIgnoreCase(\u0026quot;토끼\u0026quot;)) { return new Rabbit(); } else if (type.equalsIgnoreCase(\u0026quot;뱀\u0026quot;)) { return new Snake(); } return null; } } // 토끼 클래스 public class Rabbit implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;깡총깡총\u0026quot;); } } // 뱀 클래스 public class Snake implements Animal { @Override public void makeSound() { System.out.println(\u0026quot;실실\u0026quot;); } } // 클라이언트 코드 public class Client { public static void main(String[] args) { Animal cat = AnimalFactory.createAnimal(\u0026quot;고양이\u0026quot;); cat.makeSound(); // 출력: \u0026quot;야옹\u0026quot; Animal dog = AnimalFactory.createAnimal(\u0026quot;개\u0026quot;); dog.makeSound(); // 출력: \u0026quot;멍멍\u0026quot; Animal bird = AnimalFactory.createAnimal(\u0026quot;새\u0026quot;); bird.makeSound(); // 출력: \u0026quot;짹짹\u0026quot; Animal rabbit = AnimalFactory.createAnimal(\u0026quot;토끼\u0026quot;); rabbit.makeSound(); // 출력: \u0026quot;깡총깡총\u0026quot; Animal snake = AnimalFactory.createAnimal(\u0026quot;뱀\u0026quot;); snake.makeSound(); // 출력: \u0026quot;실실\u0026quot; } } 위의 예제에서는 Factory 패턴을 사용하여 객체를 생성하고 있지만, 팩토리 메서드의 분기문이 많아져 가독성이 저하됩니다. 새로운 동물을 추가할 때마다 AnimalFactory 클래스의 팩토리 메서드를 수정해야 하는 번거로움이 있습니다. 이러한 상황에서는 팩토리 메서드의 사용을 줄이고, 추상 팩토리 패턴을 고려하는 것이 도움이 됩니다.\nFactory 패턴과 함께 사용되는 패턴 Factory 패턴과 함께 사용하면 좋은 패턴은 추상 팩토리(Abstract Factory) 패턴입니다. 추상 팩토리 패턴은 관련된 객체들을 생성하는 인터페이스를 제공하여 객체 생성에 대한 책임을 분리합니다.\nFactory 패턴과 함께 자주 등장하는 패턴으로는 Singleton 패턴이 있습니다. Singleton 패턴은 단일 인스턴스를 보장하고, 팩토리 클래스 내에서 단일 인스턴스를 생성할 수 있습니다.\n","permalink":"https://soulsy.github.io/samtech/ko/dev/design_pattern/factory_pattern/","title":"디자인 패턴 01. Factory Pattern"},{"content":"삼테크에 오신 것을 환영합니다. 삼테크는 다양한 주제를 다루며 기술에 대한 토론을 진행하는 곳입니다. 삼테크라는 이름에 걸맞게 세 가지 주요 분야(News, Development, Knowledge)에 대해 다룹니다.\n삼테크는 보안 관련 주제도 다루지만, 주로 다양한 기술, 개발 및 IT 동향에 초점을 맞추고 있습니다. 우리는 기술 열정을 자유롭게 탐구하고 공유할 수 있는 플랫폼을 제공합니다. 함께 학습하고 정보를 교류하는 이 여정에 참여해보세요.\n","permalink":"https://soulsy.github.io/samtech/ko/about/","title":"About"}]